<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>什么时候能找到实习</title>
  
  
  <link href="https://lzjzzzzzzz.github.io/atom.xml" rel="self"/>
  
  <link href="https://lzjzzzzzzz.github.io/"/>
  <updated>2022-04-28T12:41:02.091Z</updated>
  <id>https://lzjzzzzzzz.github.io/</id>
  
  <author>
    <name>L1u</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>码蹄集OJ</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/28/matiji1/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/28/matiji1/</id>
    <published>2022-04-28T12:38:56.000Z</published>
    <updated>2022-04-28T12:41:02.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小码哥的炮火指挥"><a href="#小码哥的炮火指挥" class="headerlink" title="小码哥的炮火指挥"></a>小码哥的炮火指挥</h2><img src="/images/image-20220428203046391.png" alt="image-20220428203046391" style="zoom:50%;" /><p>很抽象的一道题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span>[] firstRound,<span class="type">int</span>[] lastRound)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lun</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(firstRound[i] == lastRound[j]) &#123;</span><br><span class="line">                        lun = i - j + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max,lun);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] firstRound = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] lastRound = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            firstRound[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">            lastRound[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> fun(n,firstRound,lastRound);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">      in.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过生日"><a href="#过生日" class="headerlink" title="过生日"></a>过生日</h2><img src="/images/image-20220428203145993.png" alt="image-20220428203145993" style="zoom:50%;" /><p>一开始我还数组排序然后用双指针，后来发现其实根本不需要。但是java过不了，爆内存了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = input.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">1</span>) num1++;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">2</span>) num2++;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">3</span>) num3++;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">4</span>) num4++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += num4;</span><br><span class="line">        num4 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num3&gt;=num1) &#123;</span><br><span class="line">            res += num3;</span><br><span class="line">            num3 = <span class="number">0</span>;</span><br><span class="line">            num1 = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res += num3;</span><br><span class="line">            num1 -= num3;</span><br><span class="line">            num3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num1*<span class="number">2</span> &gt;= num2) &#123;</span><br><span class="line">            res += num2;</span><br><span class="line">            num1 -= num2 * <span class="number">2</span>;</span><br><span class="line">            num2 = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res += (num1 + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            num2 -= (num1 + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            num1 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (num2+<span class="number">1</span>) /<span class="number">2</span>;</span><br><span class="line">        res += (num1+<span class="number">3</span>) /<span class="number">4</span>;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大约"><a href="#大约" class="headerlink" title="大约"></a>大约</h2><img src="/images/image-20220428203354050.png" alt="image-20220428203354050" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 滑动窗口 + 三指针 相当于区间内只有两个不同的数那很容易想到一种贪心的思想。</span></span><br><span class="line"><span class="comment"> * 不断更新最近的index，遇到新树更新pre指针记录区间开始的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: create in 2022/4/28 19:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">About</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num2;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] == arr[<span class="number">0</span>]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        num2 = arr[left];<span class="comment">//找到第二个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> left;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[left] == num1) &#123;</span><br><span class="line">                index1 = left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left] ==num2) &#123;</span><br><span class="line">                index2 = left;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.max(res,left - pre);</span><br><span class="line">                <span class="keyword">if</span>(index1 &lt; index2) &#123;  <span class="comment">//pre指向index在前的数字的后一个位置</span></span><br><span class="line">                    pre = index1 + <span class="number">1</span>;</span><br><span class="line">                    index1 = left;</span><br><span class="line">                    num1 = arr[left];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(index1 &gt; index2) &#123;</span><br><span class="line">                    pre = index2 + <span class="number">1</span>;</span><br><span class="line">                    index2 = left;</span><br><span class="line">                    num2 = arr[left];</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res,left-pre); <span class="comment">//最后别忘了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> fun(arr);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="圆相交"><a href="#圆相交" class="headerlink" title="圆相交"></a>圆相交</h2><blockquote><p>来段cpp</p></blockquote><img src="/images/image-20220428203515172.png" alt="image-20220428203515172" style="zoom:50%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">double</span> x1,y1,r1,x2,y2,r2;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;r1;</span><br><span class="line">cin&gt;&gt;x2&gt;&gt;y2&gt;&gt;r2;</span><br><span class="line"><span class="type">double</span> s=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);</span><br><span class="line"><span class="type">double</span> k =<span class="built_in">abs</span>(r1)+<span class="built_in">abs</span>(r2);</span><br><span class="line"><span class="type">double</span> h =<span class="built_in">abs</span>(<span class="built_in">abs</span>(r1)-<span class="built_in">abs</span>(r2));</span><br><span class="line"><span class="keyword">if</span>(h*h&lt;s&amp;&amp;s&lt;k*k )&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搬家公司"><a href="#搬家公司" class="headerlink" title="搬家公司"></a>搬家公司</h2><img src="/images/image-20220428203622944.png" alt="image-20220428203622944" style="zoom:50%;" /><blockquote><p>一眼DP</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: create in 2022/4/28 20:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BanJiaGongSi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fbi</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> fbi(n);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;小码哥的炮火指挥&quot;&gt;&lt;a href=&quot;#小码哥的炮火指挥&quot; class=&quot;headerlink&quot; title=&quot;小码哥的炮火指挥&quot;&gt;&lt;/a&gt;小码哥的炮火指挥&lt;/h2&gt;&lt;img src=&quot;/images/image-20220428203046391.png&quot; al</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://lzjzzzzzzz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>IO流(一)</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/27/IO1/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/27/IO1/</id>
    <published>2022-04-27T15:51:13.000Z</published>
    <updated>2022-04-27T15:55:36.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><ul><li><p>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。</p></li><li><p>File 能新建、删除、重命名文件和目录，但 File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。 </p></li><li><p><strong>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</strong> </p></li><li><p>File对象可以作为参数传递给流的构造器。</p></li><li><p>public File(String pathname) 以pathname为路径创建File对象，可以是<strong>绝对路径或者相对路径</strong>，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</p></li><li><p>public File(String parent,String child)以parent为父路径，child为子路径创建File对象。 </p></li><li><p>public File(File parent,String child)根据一个父File对象和子文件路径创建File对象。</p></li></ul><blockquote><ol><li>File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹）</li><li>File类声明在java.io包下</li><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li><li>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历指定目录所有文件名称，包括子文件目录中的文件。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFilesTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/Users/liuzengjin/Desktop/学习资料&quot;</span>);</span><br><span class="line">        printSubFile(dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSubFile</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        File[] subFiles = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File f : subFiles) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                printSubFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h2><ul><li><p>I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于<strong>处理设备之间的数据传输</strong>。如读/写文件，网络通讯等。</p></li><li><p>Java程序中，对于数据的输入/输出操作以<strong>“流</strong>(stream)<strong>”</strong> 的方式进行。</p></li><li><p>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过<strong>标准的方法</strong>输入或输出数据。</p></li></ul><img src="/images/image-20220427211320618.png" alt="image-20220427211320618" style="zoom:50%;" /><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a><strong>流的分类</strong></h3><ul><li><p>按操作<strong>数据单位</strong>不同分为：<strong>字节流</strong>(8 bit)<strong>，字符流</strong>(16 bit)</p></li><li><p>按数据流的<strong>流向</strong>不同分为：<strong>输入流，输出流</strong></p></li><li><p>按流的<strong>角色</strong>的不同分为：<strong>节点流，处理流</strong></p></li></ul><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td><strong>输入流</strong></td><td>InputStream</td><td>Reader</td></tr><tr><td><strong>输出流</strong></td><td>OutputStream</td><td>Writer</td></tr></tbody></table><blockquote><ul><li><p>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的。</p></li><li><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p></li></ul></blockquote><p>抽象类不能实例化，不一定有抽象方法。有抽象方法的类一定是抽象类。</p><blockquote><ol><li>read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li><li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li><li>读入的文件一定要存在，否则就会报FileNotFoundException。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderWriterTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//2.提供具体的流</span></span><br><span class="line">            fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">            <span class="comment">//3.数据的读入</span></span><br><span class="line">            <span class="comment">//read()：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        int data = fileReader.read();</span></span><br><span class="line"><span class="comment">//        while (data!=-1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.print((char) data);</span></span><br><span class="line"><span class="comment">//            data = fileReader.read();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="type">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data = fileReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(fileReader != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//4.流的关闭</span></span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>int read()从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。 </p></li><li><p>int read(char[] cbuf)将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 </p><p>遍历的时候要注意用好read方法返回的len</p></li></ul></blockquote><blockquote><p>从内存中写出数据到硬盘的文件里。 void write(String str) </p><p>说明：1.输出操作，对应的File可以不存在的，并不会报异常</p><p>2.File对应的硬盘中文件如果不存在，在输出的过程中，会自动创建此文件。</p><p>File对应的硬盘中的文件如果存在：</p><ul><li>如果流使用的构造器是：FileWriter(file,false)/FileWriter(file):对原有文件覆盖。</li><li>如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容。</li></ul><p>不能使用字符流来处理图片等字节数据，使用字节流FileInputStream处理文本文件，读出来可能出现乱码</p><p>如果使用字节流读文本文件，读到内存中，在控制台输出可能会出现乱码。如果只是复制，那么此时的字节流仅仅是一个搬运工，在复制好的文件中打开，就不会出现乱码。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;File类的使用&quot;&gt;&lt;a href=&quot;#File类的使用&quot; class=&quot;headerlink&quot; title=&quot;File类的使用&quot;&gt;&lt;/a&gt;File类的使用&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关。</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/27/generic/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/27/generic/</id>
    <published>2022-04-27T15:51:05.000Z</published>
    <updated>2022-04-27T15:51:59.954Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><ul><li><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 </p></li><li><p>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：<code>List&lt;String&gt;</code>，这表明该List只能保存字符串类型的对象。 </p></li><li><p>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</p></li></ul><img src="/images/image-20220426223259660.png" alt="image-20220426223259660" style="zoom:50%;" /><img src="/images/image-20220426223314829.png" alt="image-20220426223314829" style="zoom:50%;" /><p><strong>编译时，会进行类型检查，保证数据的安全</strong></p><blockquote><p>在集合中使用泛型</p><ul><li>集合接口或集合类在jdk5.0时都修改为带泛型的结构。</li><li>在实例化集合类时，可以指明具体的泛型类型。</li><li>指明完以后，在集合类或结构中凡是定义类或接口时，内部结构（比如：方法、构造器、属性）使用到类的泛型的位置，都指定为实例化的泛型类型。比如add(E e) —-&gt;实例化以后：add(Integer e)</li><li>泛型的类型必须时类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换。</li><li>如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</li></ul></blockquote><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &lt;T&gt;&#123;</span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line">    T orderT;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.setOrderT(<span class="number">123</span>);</span><br><span class="line">        order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">        <span class="comment">//如果定义类是泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">        Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;(<span class="string">&quot;order1&quot;</span>,<span class="number">1001</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//SubOrder类继承了Order并且泛型指定为Integer</span></span><br><span class="line">        <span class="type">SubOrder</span> <span class="variable">sub1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubOrder</span>();</span><br><span class="line">        <span class="comment">//由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span></span><br><span class="line">        sub1.setOrderT(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt;&#123;</span><br><span class="line">&#125; <span class="comment">//SubOrder不是泛型类</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubOrder</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">&#125; <span class="comment">//SubOrder仍是泛型类</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="静态方法中不能使用类的泛型，为什么？"><a href="#静态方法中不能使用类的泛型，为什么？" class="headerlink" title="静态方法中不能使用类的泛型，为什么？"></a>静态方法中不能使用类的泛型，为什么？</h2><p> 类的泛型是实例化的时候指定的，而静态结构要早于对象的创建。</p><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在方法中出现了泛型结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法所属的类是不是泛型类都没有关系。</p><ul><li>可以声明为静态的。原因：泛型参数是在调用方法时确定的，并非在实例化类时确定。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copy</span><span class="params">(E[] arr)</span> &#123; <span class="comment">//需要前面加&lt;E&gt;来声明，让编译器识别这是一个泛型方法</span></span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(E e: arr) &#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个泛型方法可以声明static，类的泛型随着构造器的加载而加载，所以不能为static，方法的泛型不跟着构造器，可以声明为static，跟着类加载</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123; <span class="comment">//泛型方法写在了Order类中</span></span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//泛型方法在调用时，指明泛型参数的类型。</span></span><br><span class="line">    List&lt;Integer&gt; list = order.copy(arr);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型在继承方面的体现"><a href="#泛型在继承方面的体现" class="headerlink" title="泛型在继承方面的体现"></a>泛型在继承方面的体现</h2><ul><li>类A是类B的父类，G<A>和G<B>二者不具备子父类关系，二者是并列关系。</li><li>类A是类B的父类,A<G>是B<G>的父类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="comment">//此时的list1和list2的类型不具有子父类关系</span></span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line">list1 = list2;</span><br><span class="line">反证法：</span><br><span class="line">假设list1 = list2;</span><br><span class="line">list1.add(<span class="number">123</span>);导致混入非String的数据，出错</span><br></pre></td></tr></table></figure><h2 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h2><p>通配符:?</p><p>类A是类B的父类，G<A>和G<B>是没有关系的，二者共同的父类是：G&lt;?&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list2.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//添加：对于List&lt;?&gt;就不能向其内部添加数据，除了null之外。</span></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">  <span class="comment">//获取（读取）：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    print(list1);</span><br><span class="line">    print(list2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有限制条件的通配符的使用"><a href="#有限制条件的通配符的使用" class="headerlink" title="有限制条件的通配符的使用"></a>有限制条件的通配符的使用</h3><ul><li><p>? extends A: G&lt;? extends A&gt;可以作为G<A>和G<B>的父类，其中B是A的子类</p></li><li><p>? super A:G&lt;? super A&gt;可以作为G<A>和G<B>的父类，其中B是A的父类</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;泛型的概念&quot;&gt;&lt;a href=&quot;#泛型的概念&quot; class=&quot;headerlink&quot; title=&quot;泛型的概念&quot;&gt;&lt;/a&gt;泛型的概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>复原ip地址</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/26/leetcode02/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/26/leetcode02/</id>
    <published>2022-04-26T05:55:02.000Z</published>
    <updated>2022-04-26T06:01:53.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复原ip地址"><a href="#复原ip地址" class="headerlink" title="复原ip地址"></a>复原ip地址</h2><blockquote><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#x31;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#64;&#49;&#46;&#x31;">&#x31;&#x39;&#50;&#46;&#x31;&#54;&#x38;&#64;&#49;&#46;&#x31;</a>“ 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p></blockquote><p><strong>示例 1：</strong></p><p><code>输入：s = &quot;25525511135&quot;</code><br><code>输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</code><br><strong>示例 2：</strong></p><p><code>输入：s = &quot;0000&quot;</code><br><code>输出：[&quot;0.0.0.0&quot;]</code><br><strong>示例 3：</strong></p><p><code>输入：s = &quot;101023&quot;</code><br><code>输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</code></p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/restore-ip-addresses">https://leetcode-cn.com/problems/restore-ip-addresses</a></p><ul><li>首先要对字符串分割，每个字符串分割的时候要注意规范长度不能大于3，且字符串内的数字在0-255之间且长度为2以上的字符串首位不能为0</li><li>由于子字符串之间要加“.”,我们可以记录”.”的数量作为递归出口</li><li>写一个isVaild函数判断子字符串是否合法</li><li>感觉用StringBuilder效率高点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()&gt;<span class="number">12</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backTracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(String s,<span class="type">int</span> index,<span class="type">int</span> pointCount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pointCount == <span class="number">3</span>) &#123; <span class="comment">//有3个&quot;.&quot;时判断最后剩下的子字符串是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(isVaild(s,index,s.length()-<span class="number">1</span>)) &#123;</span><br><span class="line">                sb.append(s.substring(index,s.length()));</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">                sb.delete(index+pointCount,pointCount+s.length());<span class="comment">//这里别忘了回溯，不然最后的网段不对</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;i&lt;s.length() &amp;&amp; i-index&lt;<span class="number">3</span> &amp;&amp; isVaild(s,index,i);i++) &#123;</span><br><span class="line">            <span class="comment">//剪枝操作：限定每个子字符串合法</span></span><br><span class="line">            sb.append(s.substring(index,i+<span class="number">1</span>));</span><br><span class="line">            sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            pointCount++;</span><br><span class="line">            backTracking(s,i+<span class="number">1</span>,pointCount);</span><br><span class="line">            pointCount--;</span><br><span class="line">            sb.delete(index+pointCount,i+pointCount+<span class="number">2</span>);</span><br><span class="line">            <span class="comment">//    i+1-index        +     index+point          +   1</span></span><br><span class="line">            <span class="comment">//要删去的子字符串的长度       在sb中该子字符串的开始位置   一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断子字符串在区间[left,right]内是否合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVaild</span><span class="params">(String s,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left != right &amp;&amp; s.charAt(left) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            num = num*<span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;复原ip地址&quot;&gt;&lt;a href=&quot;#复原ip地址&quot; class=&quot;headerlink&quot; title=&quot;复原ip地址&quot;&gt;&lt;/a&gt;复原ip地址&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含</summary>
      
    
    
    
    
    <category term="LeetCode" scheme="https://lzjzzzzzzz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Java集合(五)Collections工具类</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/25/jihe5/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/25/jihe5/</id>
    <published>2022-04-25T15:22:11.000Z</published>
    <updated>2022-04-25T15:25:52.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。</p></li><li><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p></li></ul><table><thead><tr><th>reverse(List)</th><th>反转 List 中元素的顺序</th></tr></thead><tbody><tr><td>shuffle(List)</td><td>对 List 集合元素进行随机排序</td></tr><tr><td>sort(List)</td><td>根据元素的自然顺序对指定 List 集合元素按升序排序</td></tr><tr><td>sort(List，Comparator)</td><td>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</td></tr><tr><td>swap(List，int， int)</td><td>将指定 list 集合中的 i 处元素和 j 处元素进行交换</td></tr><tr><td>Object max(Collection)/min</td><td>根据元素的自然顺序，返回给定集合中的最大元素/小</td></tr><tr><td>Object max(Collection，Comparator)/min</td><td>根据 Comparator 指定的顺序，返回给定集合中的最大元素/小</td></tr><tr><td>int frequency(Collection，Object)</td><td>返回指定集合中指定元素的出现次数</td></tr><tr><td>void copy(List dest,List src)</td><td>将src中的内容复制到dest中</td></tr><tr><td>boolean replaceAll(List list，Object oldVal，Object newVal)</td><td>使用新值替换List对象所有旧值</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//        // IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line"><span class="comment">//        List dest = new ArrayList(list.size()); //依然会报异常，即使初始化ArrayList长度，指定的是底层数组的长度，这时候</span></span><br><span class="line">        <span class="comment">//dest还是大小为0</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest,list);</span></span><br><span class="line">        <span class="comment">//正确方法</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);<span class="comment">//此时创建的dest大小为3</span></span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line">        System.out.println(dest);</span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li></ul><img src="/images/image-20220425231708252.png" alt="image-20220425231708252"  /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的list1即为线程安全的list</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Collections工具类&quot;&gt;&lt;a href=&quot;#Collections工具类&quot; class=&quot;headerlink&quot; title=&quot;Collections工具类&quot;&gt;&lt;/a&gt;Collections工具类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Collections 是</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合(四)Map接口</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/25/jihe4/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/25/jihe4/</id>
    <published>2022-04-25T15:22:09.000Z</published>
    <updated>2022-04-25T15:27:16.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h2><img src="/images/image-20220425181850387.png" alt="image-20220425181850387" style="zoom:50%;"  /><ul><li><p>Map与Collection并列存在。用于保存具有<strong>映射关系</strong>的数据:key-value</p></li><li><p>Map 中的 key 和 value 都可以是任何引用类型的数据</p></li><li><p>Map 中的 key 用Set来存放，<strong>不允许重复</strong>，即同一个 Map 对象所对应的类，须重写hashCode()和equals()方法</p></li><li><p>常用String类作为Map的“键”</p></li><li><p>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value</p></li><li><p>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是 Map 接口使用频率最高的实现类</p></li></ul><p><code>HashMap</code>作为Map的主要实现类；线程不安全，效率高；可以存储null的key和value。</p><p><code>LinkedHashMap</code>保证在遍历map元素的时，可以按照添加的顺序实现遍历。</p><blockquote><p>原因：在原有的HashMap底层结构基础上，添加 了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于HashMap。</p><p>HashMap底层：数组+链表 （jdk7之前）数组+链表+红黑树（jdk8）</p></blockquote><p><code>TreeMap</code>保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序。底层使用红黑树。</p><p><code>Hashtable</code>作为古老的实现类；线程安全，效率低；不能存储null的key和value。</p><p><code>Properties</code>常用来处理配置文件。key和value都是String类型。</p><h2 id="Map结构的理解"><a href="#Map结构的理解" class="headerlink" title="Map结构的理解"></a>Map结构的理解</h2><ul><li>Map中的key：无序的、不可重复的，使用Set存储所有的key<ul><li>key所在的类要重写euqals()和hashCode()</li></ul></li><li>Map中的value：无序的、可重复的，使用Collection存储所有的value<ul><li>value所在的类要重写equals()</li></ul></li><li>一个键值对：key-value构成一个Entry对象。</li><li>Map中的entry：无序的、不可重复的，使用Set存储所有的entry</li></ul><h2 id="HashMap的底层实现原理？"><a href="#HashMap的底层实现原理？" class="headerlink" title="HashMap的底层实现原理？"></a>HashMap的底层实现原理？</h2><p><strong>以jdk7为例说明</strong></p><blockquote><p>HashMap map = new HashMap();</p><p>在实例化以后，底层创建了长度是16的一维数组Entry[] table</p><p>…可能已经执行过多次put…</p><p>map.put(key1,value1);</p><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p><p>1⃣️如果此位置上的数据为空，此时key1-value1添加成功</p><p>如果此位置上的数据不为空，意味着此位置上存在一个或多个数据以链表形式存在，比较key1和已经存在的一个或多个数据的哈希值：2⃣️如果key1的哈希值和已经存在的数据的哈希值都不相同，那么此时key1-value1添加成功。3⃣️如果key1的哈希值和已经存在的某个数据的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，如果返回false，则添加成功。如果返回true，使用value1替换value2。</p><p>关于情况2和情况3:此时key1-value1和原来的数据以链表方式存储。</p><p>在不断添加的过程中，会涉及到扩容问题，默认的扩容方式：扩容为原来的2倍，并将原有的数据复制过来。</p></blockquote><p><strong>jdk8相较于jdk7在底层实现方面的不同</strong></p><blockquote><ul><li>new HashMap()底层没有创建一个长度为16的数组</li><li>jdk8底层的数组是Node[]，而非Entry[]</li><li>首次调用put()方法时，底层创建长度为16的数组</li><li>数组+链表 （jdk7之前）数组+链表+红黑树（jdk8）<ul><li>当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储。</li></ul></li></ul></blockquote><img src="/images/image-20220425202548677.png" alt="image-20220425202548677" style="zoom:50%;"  /><img src="/images/image-20220425202621860.png" alt="image-20220425202621860" style="zoom:50%;"  /><h3 id="关于映射关系的key是否可以修改？answer：不要修改"><a href="#关于映射关系的key是否可以修改？answer：不要修改" class="headerlink" title="关于映射关系的key是否可以修改？answer：不要修改"></a>关于映射关系的key是否可以修改？answer：不要修改</h3><p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p><h3 id="负载因子值的大小，对HashMap有什么影响"><a href="#负载因子值的大小，对HashMap有什么影响" class="headerlink" title="负载因子值的大小，对HashMap有什么影响"></a><strong>负载因子值的大小，对</strong>HashMap<strong>有什么影响</strong></h3><ul><li><p>负载因子的大小决定了HashMap的数据密度。</p></li><li><p>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长,造成查询或插入时的比较次数增多，性能会下降。</p></li><li><p>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</p></li><li><p>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数</p></li></ul><h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><ul><li><p>LinkedHashMap 是 HashMap 的子类</p></li><li><p>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</p></li><li><p>与LinkedHashSet类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</p></li></ul><img src="/images/image-20220425203122224.png" alt="image-20220425203122224" style="zoom:50%;"  /><p>LinkedHaspMap种的Entry继承了Node，并且添加了before和after，能够记录添加的元素的先后顺序</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><ul><li>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</li><li>因为要按照key进行排序：自然排序、定制排序，和TreeSet差不多</li></ul><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul><li><p>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</p></li><li><p>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</p></li><li><p>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</p></li></ul><h2 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h2><table><thead><tr><th>Object put(Object key,Object value)</th><th>将指定key-value添加到(或修改)当前map对象中</th></tr></thead><tbody><tr><td><strong>void putAll(Map m)</strong></td><td><strong>将m中的所有key-value对存放到当前map中</strong></td></tr><tr><td><strong>Object remove(Object key)</strong></td><td><strong>移除指定key的key-value对，并返回value</strong></td></tr><tr><td><strong>void clear()</strong></td><td><strong>清空当前map中的所有数据</strong></td></tr><tr><td><strong>Object get(Object key)</strong></td><td><strong>获取指定key对应的value</strong></td></tr><tr><td><strong>boolean containsKey(Object key)</strong></td><td><strong>是否包含指定的key</strong></td></tr><tr><td><strong>boolean containsValue(Object value)</strong></td><td><strong>是否包含指定的value</strong></td></tr><tr><td><strong>int size()</strong></td><td><strong>返回map中key-value对的个数</strong></td></tr><tr><td><strong>boolean isEmpty()</strong></td><td><strong>判断当前map是否为空</strong></td></tr><tr><td><strong>boolean equals(Object obj)</strong></td><td><strong>判断当前map和参数对象obj是否相等</strong></td></tr><tr><td><strong>Set keySet()</strong></td><td><strong>返回所有key构成的Set集合</strong></td></tr><tr><td><strong>Collection values()</strong></td><td><strong>返回所有value构成的Collection集合</strong></td></tr><tr><td><strong>Set entrySet()</strong></td><td><strong>返回所有key-value对构成的Set集合</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="number">45</span>,<span class="number">123</span>);</span><br><span class="line">        map.put(<span class="string">&quot;BB&quot;</span>,<span class="number">56</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//遍历所有的key集</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有的value集</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">        <span class="keyword">for</span> (Object obj : values)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有的key-value</span></span><br><span class="line">        <span class="comment">//方式一:entrySet</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="comment">//entrySet集合中的元素都是entry</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;-------&gt;&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;-----&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Map接口概述&quot;&gt;&lt;a href=&quot;#Map接口概述&quot; class=&quot;headerlink&quot; title=&quot;Map接口概述&quot;&gt;&lt;/a&gt;Map接口概述&lt;/h2&gt;&lt;img src=&quot;/images/image-20220425181850387.png&quot; alt=&quot;i</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合(三)Set接口</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/24/jihe3/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/24/jihe3/</id>
    <published>2022-04-24T15:48:40.000Z</published>
    <updated>2022-04-24T15:52:46.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set接口概述"><a href="#Set接口概述" class="headerlink" title="Set接口概述"></a>Set接口概述</h2><ul><li><p> Set接口是Collection的子接口，set接口没有提供额外的方法</p></li><li><p> Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</p></li><li><p> Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals() 方法</p></li></ul><p><code>HashSet</code> 作为Set接口的主要实现类；线程不安全；可以存储null值</p><p><code>LinkedHashSet</code>作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。对于频繁的遍历操作，LinkedHashSet效率高于HashSet</p><p><code>TreeSet</code>可以按照添加对象的指定属性，进行排序</p><ul><li>Set接口中没有额外定义新的方法，使用的都是Collection中声明的方法。</li><li>向Set中添加数据，其所在类一定要重写hashCode()和equals()</li><li>重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</li></ul><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>Set：存储无序的、不可重复的数据</strong></p><p>以HashSet为例说明：</p><ul><li>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li>不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一个。</li></ul><p>添加元素的过程：以HashSet为例</p><blockquote><p>我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（索引位置），判断数组此位置上是否已经有元素。</p><p>如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1</p><p>如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</p><ul><li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li><li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul><li>equals()返回true，元素a添加失败。</li><li>equals()返回false，元素a添加成功。—&gt;情况3</li></ul></li></ul><p>对于添加成功的情况2和情况3而言，元素a与已经存在指定索引位置上数据以链表的方式存储。</p><p>Jdk7:元素a放到数组中，指向原来的元素。</p><p>Jdk8:原来的元素在数组中，指向元素a。</p></blockquote><p>HashSet底层：数组+链表的结构</p><img src="/images/image-20220424224824190.png" alt="image-20220424224824190" style="zoom: 50%;" /><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li><p>LinkedHashSet 是 HashSet 的子类。</p></li><li><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。实际上是所在空间并不连续。</p></li><li><p>LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</p></li><li><p>LinkedHashSet 不允许集合元素重复。   </p></li></ul><img src="/images/image-20220424230453186.png" alt="image-20220424230453186" style="zoom:50%;" /><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li><p>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态。</p></li><li><p>TreeSet底层使用<strong>红黑树</strong>结构存储数据</p></li><li><p>TreeSet 两种排序方法：<strong>自然排序</strong>和<strong>定制排序</strong>。默认情况下，TreeSet 采用自然排序。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.向TreeSet中添加数据，要求是相同类对象。</span></span><br><span class="line"><span class="comment">     * 2.两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）</span></span><br><span class="line"><span class="comment">     * 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()</span></span><br><span class="line"><span class="comment">     * 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User) o1;</span><br><span class="line">                    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User) o2;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(u1.getAge(), u2.getAge());</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Marry&quot;</span>,<span class="number">56</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//User类中重写的compareTo()方法</span></span><br><span class="line"><span class="comment">//按姓名从大到小排列,年龄从小到大</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> -<span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span>(compare != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//姓名相等的情况,如果只比较姓名不比较age，那么结果中只会出现姓名相同的先加入set的元素</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age,user.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Set接口概述&quot;&gt;&lt;a href=&quot;#Set接口概述&quot; class=&quot;headerlink&quot; title=&quot;Set接口概述&quot;&gt;&lt;/a&gt;Set接口概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt; Set接口是Collection的子接口，set接口没有提供额外的方法&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java集合(二)List接口</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/24/jihe2/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/24/jihe2/</id>
    <published>2022-04-24T15:48:38.000Z</published>
    <updated>2022-04-26T06:02:06.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="List接口概述"><a href="#List接口概述" class="headerlink" title="List接口概述"></a>List接口概述</h2><ul><li><p> 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</p></li><li><p> List集合类中<strong>元素有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引。</p></li><li><p> List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</p></li><li><p> JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</p></li></ul><p><strong>List接口：存储有序的、可重复的数据。–&gt;“动态”数组，替换原有的数组</strong></p><ul><li>ArrayList：作为List接口的主要实现类：线程不安全，效率高；底层使用Object[] elementDate存储</li><li>LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</li><li>Vector：作为List接口的古老实现类；线程安全，效率低；底层使用Object[] elementData存储</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别? </p><ul><li> <strong>ArrayList和LinkedList的异同</strong></li></ul><p>二者都线程不安全，相对线程安全的Vector，执行效率高。此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</p><ul><li> <strong>ArrayList和Vector的区别</strong></li></ul><p>Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="jdk7情况下"><a href="#jdk7情况下" class="headerlink" title="jdk7情况下"></a>jdk7情况下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//底层创建了长度为10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">1</span>); <span class="comment">//elementData[0] = new Integer(1);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line">默认情况下，扩容为原来容量的<span class="number">1.5</span>倍，同时需要将原有数组中的数据复制到新的数组中。</span><br><span class="line">结论：建议开发中使用带参的构造器，避免扩容影响效率 <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(<span class="type">int</span> capacity)</span><br></pre></td></tr></table></figure><h3 id="jdk8中ArrayList的变化"><a href="#jdk8中ArrayList的变化" class="headerlink" title="jdk8中ArrayList的变化"></a>jdk8中ArrayList的变化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;,并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData</span></span><br><span class="line">后续和jdk7相同</span><br></pre></td></tr></table></figure><p><strong>jdk7中的ArrayList的对象创建类似于单例的饿汉式，jdk8中的ArrayList的对象创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</strong></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();<span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">1</span>); <span class="comment">//将123封装到Node中，创建了Node对象</span></span><br><span class="line">其中Node定义为：体现了LinkedList的双向链表的说法，也不涉及到扩容了</span><br></pre></td></tr></table></figure><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><strong>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组，在扩容方面，默认扩容为原来数组长度的2倍。</strong></p><h2 id="遍历List"><a href="#遍历List" class="headerlink" title="遍历List"></a>遍历List</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//1.Iterator</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">it</span> <span class="operator">=</span> list.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : list) &#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.普通for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++) &#123;</span><br><span class="line">System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;List接口概述&quot;&gt;&lt;a href=&quot;#List接口概述&quot; class=&quot;headerlink&quot; title=&quot;List接口概述&quot;&gt;&lt;/a&gt;List接口概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt; 鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组&lt;/</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>多个数组求交集</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/24/leetcode01/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/24/leetcode01/</id>
    <published>2022-04-24T04:27:11.000Z</published>
    <updated>2022-04-26T06:02:08.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多个数组求交集"><a href="#多个数组求交集" class="headerlink" title="多个数组求交集"></a>多个数组求交集</h2><p>这道题让我体会到了C++和java做算法题的差距，c++真的方便很多。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : nums) <span class="keyword">for</span> (<span class="type">int</span> x : v) mp[x]++;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) <span class="keyword">if</span> (it-&gt;second == nums.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：TsReaper</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/circle/discuss/F9IBSj/view/1UdWuf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>给你一个二维整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是由 <strong>不同</strong> 正整数组成的一个非空数组，按 <strong>升序排列</strong> 返回一个数组，数组中的每个元素在 <code>nums</code> <strong>所有数组</strong> 中都出现过。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]</span><br><span class="line">输出：[3,4]</span><br><span class="line">解释：</span><br><span class="line">nums[0] = [3,1,2,4,5]，nums[1] = [1,2,3,4]，nums[2] = [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li><li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li><li><code>nums[i]</code> 中的所有值 <strong>互不相同</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>[][] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map &lt;Integer,Integer&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;nums[i].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(myMap.containsKey(nums[i][j])) &#123;</span><br><span class="line">                    myMap.put(nums[i][j],myMap.get(nums[i][j])+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    myMap.put(nums[i][j],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : myMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(value == nums.length) &#123;</span><br><span class="line">                res.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多个数组求交集&quot;&gt;&lt;a href=&quot;#多个数组求交集&quot; class=&quot;headerlink&quot; title=&quot;多个数组求交集&quot;&gt;&lt;/a&gt;多个数组求交集&lt;/h2&gt;&lt;p&gt;这道题让我体会到了C++和java做算法题的差距，c++真的方便很多。。&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
    <category term="LeetCode" scheme="https://lzjzzzzzzz.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Java集合(一)</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/23/jihe1/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/23/jihe1/</id>
    <published>2022-04-23T15:19:12.000Z</published>
    <updated>2022-04-23T15:21:59.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合概述"><a href="#Java集合概述" class="headerlink" title="Java集合概述"></a>Java集合概述</h2><p>Java 集合可分为 Collection 和 Map 两种体系</p><ul><li><p>Collection<strong>接口：</strong>单列数据，定义了存取一组对象的方法的集合</p><p> List<strong>：</strong>元素有序、可重复的集合</p></li></ul><p>​        Set<strong>：</strong>元素无序、不可重复的集合</p><ul><li>Map<strong>接口：</strong>双列数据，保存具有映射关系“key-value对”的集合</li></ul><h3 id="Collection接口继承树"><a href="#Collection接口继承树" class="headerlink" title="Collection接口继承树"></a>Collection接口继承树</h3><p><img src="/images/image-20220423204358969.png" alt="image-20220423204358969"></p><h3 id="Map接口继承树"><a href="#Map接口继承树" class="headerlink" title="Map接口继承树"></a>Map接口继承树</h3><p><img src="/images/image-20220423204525047.png" alt="image-20220423204525047"></p><h2 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h2><table><thead><tr><th>add(Object obj)  addAll(Collection Coll)</th><th>添加元素</th></tr></thead><tbody><tr><td><strong>int size()</strong></td><td><strong>返回集合中元素个数</strong></td></tr><tr><td><strong>void clear()</strong></td><td><strong>清空集合</strong></td></tr><tr><td><strong>boolean isEmpty()</strong></td><td><strong>判断集合是否为空</strong></td></tr><tr><td><strong>boolean contains(Object obj)</strong></td><td><strong>是通过元素的equals方法来判断是否是同一个对象，需要重写类方法</strong></td></tr><tr><td><strong>boolean containsAll(Collection c)</strong></td><td><strong>拿两个集合的元素挨个比较是否包含集合c</strong></td></tr><tr><td><strong>boolean remove(Object obj)</strong></td><td><strong>通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</strong></td></tr><tr><td><strong>boolean removeAll(Collection coll)</strong></td><td><strong>取当前集合的差集</strong></td></tr><tr><td><strong>boolean retainAll(Collection c)</strong></td><td><strong>把交集的结果存在当前集合中，不影响c</strong></td></tr><tr><td><strong>Object[] toArray()</strong></td><td><strong>集合转成对象数组</strong></td></tr><tr><td><strong>boolean equals(Object obj)</strong></td><td><strong>逐个判断集合是否相等，List是有序的，所以碰到不相等的时候就返回false</strong></td></tr><tr><td><strong>hashCode()</strong></td><td><strong>获取集合对象的哈希值</strong></td></tr><tr><td><strong>iterator()</strong></td><td><strong>返回迭代器对象，用于集合遍历</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组---&gt;集合 调用Arrays类的静态方法asList()</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>,<span class="number">456</span>&#125;); <span class="comment">//size为1</span></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>,<span class="number">456</span>&#125;); <span class="comment">//size为2 ，包装类的对象</span></span><br></pre></td></tr></table></figure><h2 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h2><ul><li>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li><li>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tomcat&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());//报异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        //方式二：不推荐</span></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; coll.size();i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式三：推荐</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220423223129192.png" alt="image-20220423223129192"></p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ul><li><p>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方 法，不是集合对象的remove方法。 </p></li><li><p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;Tomcat&quot;</span>.equals(obj)) &#123;</span><br><span class="line">    iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><ul><li><p> Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。</p></li><li><p>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</p></li><li><p>遍历集合的底层调用Iterator完成操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for(集合元素类型 局部变量 : 集合对象)</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : coll) &#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java集合概述&quot;&gt;&lt;a href=&quot;#Java集合概述&quot; class=&quot;headerlink&quot; title=&quot;Java集合概述&quot;&gt;&lt;/a&gt;Java集合概述&lt;/h2&gt;&lt;p&gt;Java 集合可分为 Collection 和 Map 两种体系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Annotation(注解)</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/23/Annotation/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/23/Annotation/</id>
    <published>2022-04-23T09:10:10.000Z</published>
    <updated>2022-04-23T09:11:03.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解概述"><a href="#注解概述" class="headerlink" title="注解概述"></a>注解概述</h2><ul><li><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) </p></li><li><p>Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p></li><li><p>Annotation 可以像修饰符一样被使用, 可用于<strong>修饰包</strong>,<strong>类</strong>, <strong>构造器</strong>, <strong>方法</strong>, <strong>成员变量</strong>, <strong>参数</strong>, <strong>局部变量的声明</strong>, 这些信息被保存在 Annotation 的 “name=value” 对中。</p></li><li><p>注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。</p></li></ul><h2 id="常见的注解示例"><a href="#常见的注解示例" class="headerlink" title="常见的注解示例"></a><strong>常见的注解示例</strong></h2><h3 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a><strong>示例一：生成文档相关的注解</strong></h3><p>@author 标明开发该类模块的作者，多个作者之间使用,分割</p><p>@version 标明该类模块的版本</p><p>@see 参考转向，也就是相关主题</p><p>@since 从哪个版本开始增加的</p><p>@param 对方法中某参数的说明，如果没有参数就不能写</p><p>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</p><p>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</p><p>其中</p><p>@param @return 和 @exception 这三个标记都是只用于方法的。</p><p>@param的格式要求：@param 形参名 形参类型 形参说明</p><p>@return 的格式要求：@return 返回值类型 返回值说明</p><p>@exception的格式要求：@exception 异常类型 异常说明</p><p>@param和@exception可以并列多个</p><h3 id="示例二：在编译时进行格式检查-JDK内置的三个基本注解"><a href="#示例二：在编译时进行格式检查-JDK内置的三个基本注解" class="headerlink" title="示例二：在编译时进行格式检查(JDK内置的三个基本注解)"></a><strong>示例二：在编译时进行格式检查</strong>(JDK<strong>内置的三个基本注解</strong>)</h3><ul><li><p>@Override: 限定重写父类方法, 该注解只能用于方法</p></li><li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p></li><li><p>@SuppressWarnings: 抑制编译器警告  #@SuppressWarnings(“unused”) </p></li></ul><h3 id="示例三：跟踪代码依赖性，实现替代配置文件功能"><a href="#示例三：跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="示例三：跟踪代码依赖性，实现替代配置文件功能"></a><strong>示例三：跟踪代码依赖性，实现替代配置文件功能</strong></h3><p>Spring框架等</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li><p>参照@SuppressWarning定义。</p></li><li><p>内部定义成员，通常使用value表示。</p></li><li><p>可以指定成员的默认值，使用default定义。</p></li><li><p>如果自定义注解没有成员，表明是一个标识作用。</p></li><li><p>如果注解有成员，在使用注解时，需要指明成员的值。</p></li><li><p><strong>注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义。</strong></p></li></ul><h2 id="JDK中的元注解"><a href="#JDK中的元注解" class="headerlink" title="JDK中的元注解"></a>JDK中的元注解</h2><p>自定义注解通常会指明两个元注释：Retention、Target</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><strong>指定所修饰的Annotation的生命周期</strong></p><p>包含一个RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值:</p><ul><li>RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。</li><li>RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解，默认值。</li><li>RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM会保留注释。程序可以通过反射获取该注解。</li></ul><p><img src="/images/image-20220423155132405.png" alt="image-20220423155132405"></p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</p><table><thead><tr><th>取值(ElementType)</th><th></th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于描述构造器</td></tr><tr><td>FIELD</td><td>用于描述域</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于描述局部变量</td></tr><tr><td>METHOD</td><td>用于描述方法</td></tr><tr><td>PACKAGE</td><td>用于描述包</td></tr><tr><td>PARAMETER</td><td>用于描述参数</td></tr><tr><td>TYPE</td><td>用于描述类、接口(包括注解类型)或enum声明</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 </p><ul><li>定义为Documented的注解必须设置Retention值为RUNTIME。</li></ul><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>@Inherited: 被它修饰的 Annotation 将具有<strong>继承性</strong>。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。</p><ul><li>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以</li></ul><p>继承父类类级别的注解</p><ul><li>实际应用中，使用较少</li></ul><h2 id="JKD8中注解的新特性"><a href="#JKD8中注解的新特性" class="headerlink" title="JKD8中注解的新特性"></a>JKD8中注解的新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><ol><li><p>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p></li><li><p>MyAnnotation的Target和Retention等元注解和MyAnnotations相同</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyAnnotation.java</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MyAnnotations.java</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可重复注解  </span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;12&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;23&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//创建一个对应当前时间的Date对象</span></span><br><span class="line">    System.out.println(date1.toString()); <span class="comment">//CST是china Standard Time</span></span><br><span class="line">    System.out.println(date1.getTime()); <span class="comment">//获取当前date对象对应的毫秒数</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1650598323255L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p><strong>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE。</strong></p><ul><li><p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 </p></li><li><p>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注解概述&quot;&gt;&lt;a href=&quot;#注解概述&quot; class=&quot;headerlink&quot; title=&quot;注解概述&quot;&gt;&lt;/a&gt;注解概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotati</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>枚举类</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/23/enum/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/23/enum/</id>
    <published>2022-04-23T06:08:59.000Z</published>
    <updated>2022-04-23T06:09:40.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举类的实现"><a href="#枚举类的实现" class="headerlink" title="枚举类的实现"></a>枚举类的实现</h2><ul><li><p><strong>JDK1.5之前需要自定义枚举类</strong></p></li><li><p><strong>JDK 1.5 新增的 enum 关键字用于定义枚举类</strong></p></li><li><p><strong>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</strong></p></li><li><p><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></p></li></ul><h2 id="枚举类的属性"><a href="#枚举类的属性" class="headerlink" title="枚举类的属性"></a><strong>枚举类的属性</strong></h2><ul><li><p><strong>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰</strong></p></li><li><p><strong>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</strong></p></li><li><p><strong>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</strong></p></li></ul><h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><ol><li><p><strong>私有化类的构造器，保证不能在类的外部创建其对象</strong></p></li><li><p><strong>在类的内部创建枚举类的实例。声明为：public static final</strong> </p></li><li><p><strong>对象如果有实例变量，应该声明为private final，并在构造器中初始化</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">  <span class="comment">//声明Season对象的属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">  <span class="comment">//私有化类构造器，给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = seasonDesc; </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//提供当前枚举类的多个对象 public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">  <span class="comment">//获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用enum定义枚举类"><a href="#使用enum定义枚举类" class="headerlink" title="使用enum定义枚举类"></a><strong>使用enum定义枚举类</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">  <span class="comment">//多个对象用逗号隔开，而且省略了public static final，末尾对象用分号结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h2><ul><li><p><strong>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</strong></p></li><li><p><strong>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</strong> ！！返回枚举类中对象名是str的对象</p></li><li><p><strong>toString()：返回当前枚举类对象常量的名称</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread.State[] states = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; states.length;i++) &#123;</span><br><span class="line">  System.out.println(states[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程的状态</span></span><br><span class="line">NEW</span><br><span class="line">RUNNABLE</span><br><span class="line">BLOCKED</span><br><span class="line">WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><h2 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a><strong>实现接口的枚举类</strong></h2><ul><li><p>和普通 Java 类一样，枚举类可以实现一个或多个接口</p></li><li><p>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</p></li><li><p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">  <span class="comment">//多个对象用逗号隔开，而且省略了public static final，末尾对象用分号结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举类的实现&quot;&gt;&lt;a href=&quot;#枚举类的实现&quot; class=&quot;headerlink&quot; title=&quot;枚举类的实现&quot;&gt;&lt;/a&gt;枚举类的实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JDK1.5之前需要自定义枚举类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/22/String/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/22/String/</id>
    <published>2022-04-22T12:37:53.000Z</published>
    <updated>2022-04-22T12:38:32.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>String：字符串，使用一对””引起来表示。</p><ul><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的</p><pre><code>            实现了Comparable接口：表示String可以比较大小</code></pre></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>String：代表不可变的字符序列。简称：不可变性。</p><p>体现：1. 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><p>​            2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p><p>​            3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域。</p></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></li><li><p><strong>字符串常量池中是不会存储相同内容的字符串的</strong></p></li></ul><h2 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a); </span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure><p><strong>String str1 = “abc”;与String str2 = new String(“abc”);的区别？</strong></p><ul><li>字符串常量存储在字符串常量池，目的是共享</li><li>字符串非常量对象存储在堆中。即使定义的时字面量值相等的字符串，其在堆中的地址也不同。</li></ul><p><strong>String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？</strong></p><p>答：两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p><p><strong>字符串拼接的特性</strong></p><ul><li>常量与常量的拼接结果在常量池，且常量池不会存在相同内容的常量。</li><li>只要其中有一个是变量，结果就在堆中</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列程序运行的结果：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>); <span class="comment">//good and</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">  System.out.println(s1 == s3); <span class="comment">//true，因为s2前面加了final视为常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><table><thead><tr><th>int length()</th><th>返回字符串的长度：value.length</th></tr></thead><tbody><tr><td><strong>char charAt(int index)</strong></td><td><strong>返回指定索引处的字符return value[index]</strong></td></tr><tr><td><strong>boolean isEmpty()</strong></td><td><strong>判断是否是空字符串</strong></td></tr><tr><td><strong>String toLowerCase()</strong></td><td><strong>将字符串转化为小写</strong></td></tr><tr><td><strong>String toUpperCase()</strong></td><td><strong>将字符串转化为大写</strong></td></tr><tr><td><strong>String trim()</strong></td><td><strong>返回字符串的副本，忽略前导空白和尾部空白</strong></td></tr><tr><td><strong>boolean equals(Object obj)</strong></td><td><strong>比较字符串的内容是否相同</strong></td></tr><tr><td><strong>boolean equalsIgnoreCase(String anotherString)</strong></td><td><strong>忽略大小写地比较两个字符串内容是否相同</strong></td></tr><tr><td><strong>String concat(String str)</strong></td><td><strong>将指定字符串连接到此字符串的结尾。 等价于用“+”</strong></td></tr><tr><td><strong>int compareTo(String anotherString)</strong></td><td><strong>比较两个字符串的大小</strong> “abc”.compareTo(“abe”)返回值为-2</td></tr><tr><td><strong>String substring(int beginIndex)</strong></td><td><strong>返回一个新的字符串，它是从此字符串的beginIndex开始截取到最后</strong></td></tr><tr><td><strong>String substring(int beginIndex, int endIndex)</strong></td><td><strong>左闭右开截取子字符串</strong></td></tr><tr><td><strong>boolean endsWith(String suffix)</strong></td><td><strong>测试此字符串是否以指定的后缀结束</strong></td></tr><tr><td><strong>boolean startsWith(String prefix)</strong></td><td><strong>测试此字符串是否以指定的前缀开始</strong></td></tr><tr><td><strong>boolean startsWith(String prefix, int toffset)</strong></td><td><strong>测试此字符串从指定索引开始的子字符串是否以指定前缀开始</strong></td></tr><tr><td><strong>boolean contains(CharSequence s)</strong></td><td><strong>当且仅当此字符串包含指定的 char 值序列时，返回 true</strong></td></tr><tr><td><strong>int indexOf(String str)</strong></td><td><strong>返回指定子字符串在此字符串中第一次出现处的索引</strong></td></tr><tr><td><strong>int indexOf(String str, int fromIndex)</strong></td><td><strong>返回从指定索引开始出现的子字符串的位置</strong></td></tr><tr><td><strong>int lastIndexOf(String str)</strong></td><td><strong>返回指定子字符串在此字符串中最右边出现处的索引</strong></td></tr><tr><td><strong>int lastIndexOf(String str, int fromIndex)</strong></td><td><strong>子字符串在字符串中最后一次出现处的索引，从指定的索引开始反向搜索</strong></td></tr><tr><td><strong>String replace(char oldChar, char newChar)</strong></td><td><strong>newChar 替换此字符串中出现的所有 oldChar</strong></td></tr><tr><td><strong>String replace(CharSequence target, CharSequence replacement)</strong></td><td><strong>用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</strong></td></tr><tr><td><strong>String replaceAll(String regex, String replacement)</strong></td><td><strong>用给定的repalcemet替换此字符串所有匹配给定正则的子字符串</strong></td></tr><tr><td><strong>String replaceFirst(String regex, String replacement)</strong></td><td><strong>替换掉第一个正则匹配到的子字符串</strong></td></tr><tr><td><strong>boolean matches(String regex)</strong></td><td><strong>是否匹配正则</strong></td></tr><tr><td><strong>String[] split(String regex)</strong></td><td><strong>根据给定正则表达式的匹配拆分此字符串。</strong></td></tr><tr><td><strong>String[] split(String regex, int limit)</strong></td><td><strong>根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line"><span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(string); <span class="comment">// hello,world,java,mysql</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"><span class="comment">//[&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>CharSequence与String的区别是什么？</strong></p><p>CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列。</p><p>CharSequence是实现这个接口的实例 举例： CharSequence str = “dd”; 就是 CharSequence str = new String(“dd”);</p><p>原文链接：<a href="https://blog.csdn.net/xiaohui2015/article/details/47148663">https://blog.csdn.net/xiaohui2015/article/details/47148663</a></p><h2 id="String与基本数据类型转换"><a href="#String与基本数据类型转换" class="headerlink" title="String与基本数据类型转换"></a>String与基本数据类型转换</h2><p><strong>字符串</strong>➡️<strong>基本数据类型、包装类</strong></p><ul><li>Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li><li>类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> Double.parseDouble(s3);</span><br><span class="line">System.out.println(num3); <span class="comment">//123.45</span></span><br></pre></td></tr></table></figure><p><strong>基本数据类型、包装类</strong>➡️<strong>字符串</strong></p><ul><li>调用String类的public String valueOf(int n)可将int型转换为字符串</li><li>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> String.valueOf(num3);</span><br><span class="line">System.out.println(s4); <span class="comment">//&quot;123.45&quot;</span></span><br></pre></td></tr></table></figure><h2 id="String与字符数组转换"><a href="#String与字符数组转换" class="headerlink" title="String与字符数组转换"></a>String与字符数组转换</h2><p><strong>字符数组➡️字符串</strong></p><ul><li>String 类的构造器：String(char[]) <strong>和</strong> String(char[]<strong>，</strong>int offset<strong>，</strong>int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</li></ul><p><strong>字符串➡️字符数组</strong></p><ul><li>public char[] toCharArray()<strong>：</strong>将字符串中的全部字符存放在一个字符数组中的方法。</li><li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<strong>：</strong>提供了将指定索引范围内的字符串存放到数组中的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray(); <span class="comment">//&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;&#125;</span></span><br><span class="line"><span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr); <span class="comment">//&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="String与字节数组转换"><a href="#String与字节数组转换" class="headerlink" title="String与字节数组转换"></a>String与字节数组转换</h2><p><strong>字节数组➡️字符串</strong></p><ul><li>String(byte[])<strong>：</strong>通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[]<strong>，</strong>int offset<strong>，</strong>int length) <strong>：</strong>用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</li></ul><p><strong>字符串➡️字节数组</strong></p><ul><li>public byte[] getBytes() <strong>：</strong>使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</li><li>public byte[] getBytes(String charsetName) <strong>：</strong>使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//默认为utf-8,可以传参数，比如gbk</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));<span class="comment">//[97,98,99]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认字符集进行解码</span></span><br><span class="line">System.out.println(str2);<span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对比String、StringBuffer、StringBuilder"><a href="#对比String、StringBuffer、StringBuilder" class="headerlink" title="对比String、StringBuffer、StringBuilder"></a>对比String、StringBuffer、StringBuilder</h2><ul><li>String：不可变字符序列</li><li>StringBuffer：可变字符序列、效率低、线程安全</li><li>StringBuilder：可变字符序列、效率高、线程不安全。jdk5.0新增的</li><li>作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</li><li>在开发中考虑是否时多线程问题，底层都是用char[]数组存储。</li></ul><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>StringBuffer<strong>类不同于</strong>String<strong>，其对象必须使用构造器生成。有三个构造器：</strong></p><ul><li>StringBuffer()：初始容量为16的字符串缓冲区</li><li>StringBuffer(int size)：构造指定容量的字符串缓冲区</li><li>StringBuffer(String str)：将内容初始化为指定字符串内容</li></ul><p>扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。</p><p>指导意义：开发中建议大家使用：StringBuffer(int capacity)或StringBuilder(int capacity)</p><h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><table><thead><tr><th>append(xxx)</th><th>用于字符串拼接</th></tr></thead><tbody><tr><td><strong>delete(int start,int end)</strong></td><td><strong>删除指定内容</strong></td></tr><tr><td><strong>replace(int start,int end,String str)</strong></td><td><strong>把[start,end)位置替换为str</strong></td></tr><tr><td><strong>insert(int offset,xxx)</strong></td><td><strong>在指定位置插入xxx</strong></td></tr><tr><td><strong>reverse()</strong></td><td><strong>把当前字符序列逆转</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还定义了如下方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> n )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n ,<span class="type">char</span> ch)</span></span><br></pre></td></tr></table></figure><p><strong>StringBuilder 和 StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;String类&quot;&gt;&lt;a href=&quot;#String类&quot; class=&quot;headerlink&quot; title=&quot;String类&quot;&gt;&lt;/a&gt;String类&lt;/h2&gt;&lt;p&gt;String：字符串，使用一对””引起来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String声明为f</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java比较器</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/22/javaCompare/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/22/javaCompare/</id>
    <published>2022-04-22T12:22:09.000Z</published>
    <updated>2022-04-22T12:25:32.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自然排序-java-lang-Comparable"><a href="#自然排序-java-lang-Comparable" class="headerlink" title="自然排序 java.lang.Comparable"></a>自然排序 <strong>java.lang.Comparable</strong></h2><p><strong>CompareTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java中的对象，正常情况下只能进行比较==或！=。不能使用&gt;或&lt;的。</span></span><br><span class="line"><span class="comment"> * 但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</span></span><br><span class="line"><span class="comment"> * 如何实现？</span></span><br><span class="line"><span class="comment"> * 使用comparable或者comparator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string、包装类等实现了comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方式。</span></span><br><span class="line"><span class="comment">     * string、包装类重写compareTo()方法后，进行了从小到大排列。</span></span><br><span class="line"><span class="comment">     * 重写compareTo(obj)规则：</span></span><br><span class="line"><span class="comment">     * 1.如果当前对象this大于形参对象obj，则返回正整数。</span></span><br><span class="line"><span class="comment">     * 2.如果当前对象this小于形参对象obj，则返回负整数。</span></span><br><span class="line"><span class="comment">     * 3.如果当前对象this等于形参对象obj，则返回0。</span></span><br><span class="line"><span class="comment">     * 对于自定义类来说，如果需要排序的话，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</span></span><br><span class="line"><span class="comment">     * 在compareTo(obj)方法中指明如何排序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;a&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;b&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;c&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;d&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;e&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Goods.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器、get、set、toString方法省略</span></span><br><span class="line">    <span class="comment">//指明商品比较大小方式,按价格从低到高排序,名称升序</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//这里返回1是，this.price比goods.price大，返回1就可以理解为放在后面的意思</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//return 0;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">                <span class="comment">//return -this.name.compareTo(goods.name); //从高到低</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//            return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="定制排序-java-util-Comparator"><a href="#定制排序-java-util-Comparator" class="headerlink" title="定制排序 java.util.Comparator"></a>定制排序 <strong>java.util.Comparator</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那</span></span><br><span class="line"><span class="comment">     * 么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</span></span><br><span class="line"><span class="comment">     * 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示</span></span><br><span class="line"><span class="comment">     * o1小于o2。</span></span><br><span class="line"><span class="comment">     * 3.可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</span></span><br><span class="line"><span class="comment">     * 4.还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        Goods[] arr1 = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;a&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;a&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr1[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;c&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr1[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;d&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr1[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;e&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        Arrays.sort(arr1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Goods&gt;() &#123;</span><br><span class="line">            <span class="comment">//指定产品名称从低到高，再按价格从高到低</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Goods o1, Goods o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -Double.compare(o1.getPrice(),o2.getPrice());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        <span class="comment">//[Goods&#123;name=&#x27;a&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;a&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;c&#x27;, price=12.0&#125;, Goods&#123;name=&#x27;d&#x27;, price=65.0&#125;, Goods&#123;name=&#x27;e&#x27;, price=43.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Comparable接口与Comparator的使用对比"><a href="#Comparable接口与Comparator的使用对比" class="headerlink" title="Comparable接口与Comparator的使用对比"></a>Comparable接口与Comparator的使用对比</h2><ul><li><p><strong>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小</strong></p></li><li><p><strong>Comparator接口属于临时性的比较。</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自然排序-java-lang-Comparable&quot;&gt;&lt;a href=&quot;#自然排序-java-lang-Comparable&quot; class=&quot;headerlink&quot; title=&quot;自然排序 java.lang.Comparable&quot;&gt;&lt;/a&gt;自然排序 &lt;stron</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/18/Mysql1/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/18/Mysql1/</id>
    <published>2022-04-18T06:06:35.000Z</published>
    <updated>2022-04-23T15:24:05.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p><img src="/images/image-20220305154604127.png" alt="image-20220305154604127"></p><p><img src="/images/image-20220305154703681.png" alt="image-20220305154703681"></p><h3 id="DDL-数据库操作"><a href="#DDL-数据库操作" class="headerlink" title="DDL-数据库操作"></a>DDL-数据库操作</h3><p><img src="/images/image-20220305154955897.png" alt="image-20220305154955897"></p><p><img src="/images/image-20220305155727834.png" alt="image-20220305155727834"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database it <span class="keyword">default</span> charset utf8m64 <span class="operator">/</span><span class="operator">/</span>指定字符集</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220305160003976.png" alt="image-20220305160003976"></p><p>切换到itcast //查看当前数据库</p><p><img src="/images/image-20220305160306038.png" alt="image-20220305160306038"></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><img src="/images/image-20220305170217431.png" alt="image-20220305170217431"></p><p><img src="/images/image-20220305170256512.png" alt="image-20220305170256512"> </p><p><img src="/images/image-20220305170632472.png" alt="image-20220305170632472"></p><p><img src="/images/image-20220305171141059.png" alt="image-20220305171141059"></p><p><img src="/images/image-20220305171316617.png" alt="image-20220305171316617"></p><p><img src="/images/image-20220305171443259.png" alt="image-20220305171443259"></p><p><img src="/images/image-20220305171512487.png" alt="image-20220305171512487"></p><p><img src="/images/image-20220305171557351.png" alt="image-20220305171557351"></p><p><img src="/images/image-20220305171608798.png" alt="image-20220305171608798"></p><p><img src="/images/image-20220305171745754.png" alt="image-20220305171745754"></p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><img src="/images/image-20220305213759930.png" alt="image-20220305213759930"></p><p><img src="/images/image-20220306155706393.png" alt="image-20220306155706393"></p><p><img src="/images/image-20220306155746215.png" alt="image-20220306155746215"></p><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p><img src="/images/image-20220306160023343.png" alt="image-20220306160023343"></p><p><img src="/images/image-20220306160103900.png" alt="image-20220306160103900"></p><p><img src="/images/image-20220306160314627.png" alt="image-20220306160314627"></p><p> <img src="/images/image-20220306160714696.png" alt="image-20220306160714696"></p><p>null值不不参与所有聚合函数运算</p><p><img src="/images/image-20220306175054385.png" alt="image-20220306175054385"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询年龄小于<span class="number">45</span>的员工，并根据工作地址分组，获取员工数量大于等于<span class="number">3</span>的工作地址</span><br><span class="line"><span class="keyword">select</span> workaddress,<span class="built_in">count</span>(<span class="operator">*</span>) address_count <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span><span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#根据年龄对公司的员工进行生序排序，年龄相同，再按照入职时间进行降序排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , entrydate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220306191159996.png" alt="image-20220306191159996"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询第二页数据，每页展示<span class="number">10</span>条记录 <span class="comment">-------&gt;（页码-1）*页展示记录数</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220306191716166.png" alt="image-20220306191716166"></p><p><img src="/images/image-20220306191932848.png" alt="image-20220306191932848"></p><h3 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h3><p><img src="/images/image-20220306192151671.png" alt="image-20220306192151671"></p><p>可以在关键词后面编写字段别名验证执行顺序</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p><img src="/images/image-20220306194157844.png" alt="image-20220306194157844"></p><p><img src="/images/image-20220306194109110.png" alt="image-20220306194109110"></p><p><img src="/images/image-20220306194501896.png" alt="image-20220306194501896"></p><p><img src="/images/image-20220306195325544.png" alt="image-20220306195325544"></p><p><img src="/images/image-20220306195343435.png" alt="image-20220306195343435"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p> <img src="/images/image-20220306200025732.png" alt="image-20220306200025732"></p><p>select 函数(参数)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;Hello World&#x27;</span>,<span class="number">1</span>,<span class="number">5</span>); #Hello</span><br><span class="line">#将企业员工工号不足<span class="number">5</span>位数的全部在前面补<span class="number">0</span>，比如：<span class="number">1</span>号员工的工号应该为<span class="number">00001</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> workno <span class="operator">=</span> lpad(workno,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>); # <span class="number">1</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">00001</span></span><br></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p><img src="/images/image-20220306201101682.png" alt="image-20220306201101682"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#通过数据库的函数，生成一个六位数的随机验证码</span><br><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>,<span class="number">0</span>),<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>); #<span class="number">0</span><span class="number">-1</span>之间的随机小数乘<span class="number">1000000</span>，再四舍五入保留<span class="number">0</span>位小数，不足<span class="number">6</span>位补<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p><img src="/images/image-20220307110331776.png" alt="image-20220307110331776"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#往后推<span class="number">70</span>年</span><br><span class="line"><span class="keyword">select</span> date_add(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">YEAR</span>);</span><br><span class="line">#datediff 第一个时间减去第二个时间</span><br><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2021-12-01&#x27;</span>,<span class="string">&#x27;2021-11-01&#x27;</span>);</span><br><span class="line">#查询所有员工的入职天数，并根据入职天数倒序排序</span><br><span class="line"><span class="keyword">select</span> name,datediff(curdate(),entrydate) <span class="keyword">as</span> <span class="string">&#x27;entrydays&#x27;</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> entrydays <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307111248187.png" alt="image-20220307111248187"></p><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p> <img src="/images/image-20220307135051502.png" alt="image-20220307135051502"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ifnull(<span class="keyword">null</span>,<span class="string">&#x27;default&#x27;</span>); # <span class="keyword">default</span></span><br><span class="line">#<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">then</span> <span class="keyword">else</span> <span class="keyword">end</span></span><br><span class="line">#需求：查询emp表的员工姓名和工作地址（北京、上海<span class="comment">--&gt;一线城市，其他--&gt;二线城市）</span></span><br><span class="line"><span class="keyword">select</span> name, (<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span>       <span class="keyword">from</span> emp;</span><br><span class="line">#案例：统计班级各个学员的成绩，展示的规则如下：<span class="operator">&gt;=</span><span class="number">85</span>,展示优秀 <span class="operator">&gt;=</span><span class="number">60</span>,展示及格 否则展示不及格</span><br><span class="line"><span class="keyword">select</span> id,name,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> english <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> chinese <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;语文&#x27;</span></span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/image-20220307141410326.png" alt="image-20220307141410326"></p><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="/images/image-20220307143033603.png" alt="image-20220307143033603"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="外建约束"><a href="#外建约束" class="headerlink" title="外建约束"></a>外建约束</h3><p><img src="/images/image-20220307145628303.png" alt="image-20220307145628303"></p><p><img src="/images/image-20220307151035004.png" alt="image-20220307151035004"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#添加外建  给emp表的部门dept_id添加外建关联dept表的id</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line">#给子表添加外建之后，我们不能更新或者删除父表的记录，因为存在外键的关联</span><br><span class="line">#删除外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_emp_dept_id;</span><br><span class="line">#外键的删除和更新行为 级联</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307151312372.png" alt="image-20220307151312372"></p><p><img src="/images/image-20220307151634171.png" alt="image-20220307151634171"></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p><img src="/images/image-20220307152653485.png" alt="image-20220307152653485"></p><p><img src="/images/image-20220307152759271.png" alt="image-20220307152759271"></p><p><img src="/images/image-20220307152849934.png" alt="image-20220307152849934"></p><p><img src="/images/image-20220307153228042.png" alt="image-20220307153228042"></p><h3 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h3><p><img src="/images/image-20220307155850722.png" alt="image-20220307155850722"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#多表查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307160246157.png" alt="image-20220307160246157"></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p><img src="/images/image-20220307160428361.png" alt="image-20220307160428361"></p><p><img src="/images/image-20220307160843190.png" alt="image-20220307160843190"></p><p><img src="/images/image-20220307160910221.png" alt="image-20220307160910221"></p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><img src="/images/image-20220307161114398.png" alt="image-20220307161114398"></p><p>左外连接会完全包含左表的数据，即使是null</p><p><img src="/images/image-20220307161510886.png" alt="image-20220307161510886"></p><p>  右外连接</p><p><img src="/images/image-20220307161726442.png" alt="image-20220307161726442"></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><img src="/images/image-20220307162259920.png" alt="image-20220307162259920"></p><p><img src="/images/image-20220307162148436.png" alt="image-20220307162148436"></p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p><img src="/images/image-20220307162608284.png" alt="image-20220307162608284"></p><p><img src="/images/image-20220307162522640.png" alt="image-20220307162522640"></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><img src="/images/image-20220307204819480.png" alt="image-20220307204819480"></p><p><img src="/images/image-20220307210031925.png" alt="image-20220307210031925"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#标量子查询</span><br><span class="line">#查询“销售部”的所有员工信息 </span><br><span class="line">#a.查询“销售”部门id </span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line">#b.根据销售部部门id，查询员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line">#查询“房东白”入职之后的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;房东白&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307210100098.png" alt="image-20220307210100098"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#列子查询</span><br><span class="line">#<span class="number">1.</span>查询“销售部”和“市场部”的所有员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line">#<span class="number">2.</span>查询比财务部所有人工资都高的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line">#<span class="number">3.</span>查询比研发部其中任意一人工资高的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307214447568.png" alt="image-20220307214447568"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>查询与张无忌的薪资及直属领导相同的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220308100305770.png" alt="image-20220308100305770"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询与“鹿杖客”、“宋远桥”的职位和薪资相同的员工信息</span><br><span class="line">a查询返回的是表，<span class="keyword">in</span> 在返回的表中信息多选一，要么满足上面的要么满足下面的 </span><br><span class="line"></span><br><span class="line">#查询入职日期是“<span class="number">2006</span><span class="number">-01</span><span class="number">-01</span>”之后的员工信息，及其部门信息</span><br><span class="line">#a.入职日期是“<span class="number">2006</span><span class="number">-01</span><span class="number">-01</span>”之后的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line">#b.查询这部分员工，对应的部门信息</span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220308100527437.png" alt="image-20220308100527437"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220308125803696.png" alt="image-20220308125803696"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h3><p>如果在事务的执行过程中出现了异常，那我们得回滚事务，从而来保证数据的完整性和一致性。</p><p>MySQL事务是默认自动提交的</p><p><img src="/images/image-20220308130557717.png" alt="image-20220308130557717"></p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p><img src="/images/image-20220308132526189.png" alt="image-20220308132526189"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="variable">@autocommit</span> 为<span class="number">1</span>说明事物自动提交 为<span class="number">0</span>说明手动提交</span><br><span class="line">#转账操作 </span><br><span class="line">#<span class="number">1.</span>查询张三账户余额</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">2.</span>将张三账户余额<span class="number">-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">3.</span>将李四账户余额<span class="operator">+</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="/images/image-20220308133315314.png" alt="image-20220308133315314"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#转账操作 </span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">#<span class="number">1.</span>查询张三账户余额</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">2.</span>将张三账户余额<span class="number">-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">3.</span>将李四账户余额<span class="operator">+</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">#提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">#回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h3 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h3><p><img src="/images/image-20220308134331227.png" alt="image-20220308134331227"></p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p> <img src="/images/image-20220308150547235.png" alt="image-20220308150547235"></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="/images/image-20220308150826913.png" alt="image-20220308150826913"></p><p>从上到下性能变差，事务安全性变高。所以要权衡数据库的安全性和并发性。</p><p><img src="/images/image-20220308150938771.png" alt="image-20220308150938771"></p><p>脏读：原始数据0 B事务+1000，还没commit A事务查询：1000</p><p>不可重复读：原始数据：0,B事务+1000,A事务查询第一次：0 Bcommit之后 A事务查询：1000  </p><p>幻读：A事务查询id为3的数据为空—&gt;B事务插入id为3的数据并且commit—&gt;A事务插入id为3的数据失败，显示重复的id已经存在—&gt;A事务查询id为3的数据为空（出现“幻觉  ”）-&gt;commit A ，数据表中出现B提交的数据</p><p>Serializable：A事务查询id为4的数据为空—&gt;B事务插入id为4的数据（阻塞—&gt;A事务插入id为4的数据—&gt;commitA—&gt;B事务Error：id为4的事务已经提交</p><p><strong>串行化指的是：在进行并发操作的时候只允许一次一个事务来操作</strong> </p><p><strong>事务隔离级别越高，数据越安全，但是性能越低</strong></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="/images/image-20220308160342653.png" alt="image-20220308160342653"></p><p><img src="/images/image-20220308160404844.png" alt="image-20220308160404844"></p><h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><p>不同的存储引擎在存储数据、建议索引、更新\查询等技术的实现方式不一样。  </p><p>存储引擎就是存储数据、建议索引、更新\查询等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称之为表类型。</p><p>默认存储引擎：InnoDB</p><p><img src="/images/image-20220308192507590.png" alt="image-20220308192507590"></p><p><img src="/images/image-20220308212849926.png" alt="image-20220308212849926"></p><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><p><img src="/images/image-20220308212639638.png" alt="image-20220308212639638"></p><p><img src="/images/image-20220308213453139.png" alt="image-20220308213453139"></p><p><img src="/images/image-20220308220554874.png" alt="image-20220308220554874"></p><p><img src="/images/image-20220308220706033.png" alt="image-20220308220706033"></p><p><img src="/images/image-20220308220858786.png" alt="image-20220308220858786"></p><p><strong>InnoDB与MyISAM三大区别：InnoDB是支持事务的，而MyISAM不支持。InnoDB支持行锁，而MyISAM支持表锁；InnoDB支持外键，而MyISAM不支持。</strong></p><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>存储引擎没有好坏之分，我们只要在合适的场景选用合适的存储引擎即可。</p><p><img src="/images/image-20220308221600496.png" alt="image-20220308221600496"></p><p><strong>现在基本上MyISAM被MongoDB所替代，而在使用MEMORY的场景被Redis所替代</strong> </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><img src="/images/image-20220310172649093.png" alt="image-20220310172649093"></p><p> <img src="/images/image-20220310173008544.png" alt="image-20220310173008544"></p><p> <img src="/images/image-20220310173152469.png" alt="image-20220310173152469"></p><p>劣势基本可以忽略：1.磁盘现在是很便宜的 2.对于一个正常的业务系统来说，增删改的比例很小，主要是查询</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><img src="/images/image-20220310173645519.png" alt="image-20220310173645519"></p><p><img src="/images/image-20220310173726059.png" alt="image-20220310173726059"></p><p>我们平时所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p><p><img src="/images/image-20220310174324552.png" alt="image-20220310174324552"></p><p><img src="/images/image-20220310223433288.png" alt="image-20220310223433288"></p><p><img src="/images/image-20220310175142111.png" alt="image-20220310175142111"></p><p><img src="/images/image-20220310175810503.png" alt="image-20220310175810503"></p><p><strong>所有的元素都会出现在叶子结点，在B+树的数据结构中，叶子结点形成了一个单向链表</strong></p><p> <img src="/images/image-20220310222314054.png" alt="image-20220310222314054"></p><p><img src="/images/image-20220310222416929.png" alt="image-20220310222416929"></p><p><img src="/images/image-20220310222813547.png" alt="image-20220310222813547"></p><p><img src="/images/image-20220310223107506.png" alt="image-20220310223107506"></p><p>​    <img src="/images/image-20220311143610346.png" alt="image-20220311143610346"></p><p><strong>在B+树的结构中叶子结点形成了双向链表，便于范围搜素和采集，不管查找哪一个数据都要到叶子结点中去搜索，搜索效率稳定</strong></p><p><strong>为什么不用Hash索引？Hash索引只支持等值匹配，不支持范围匹配及排序操作</strong> </p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="/images/image-20220311143811615.png" alt="image-20220311143811615"></p><p>  <img src="/images/image-20220311144154244.png" alt=" "></p><p>​    <img src="/images/image-20220311144419306.png" alt="image-20220311144419306"></p><p><strong>聚集索引下面的row表示一整行的数据</strong></p><p><strong>二级索引下面叶子结点挂的是对应的id</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当我们执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span> 时</span><br><span class="line">先走二级索引拿到Arm对应的<span class="number">10</span>，然后再到聚集索引中进行对比</span><br><span class="line">回表查询：指的是先走二级索引找到对应的主键值，再根据主键值到聚集索引中拿到这一行的行数据</span><br></pre></td></tr></table></figure><p> == <strong>回表查询：指的是先走二级索引找到对应的主键值，再根据主键值到聚集索引中拿到这一行的行数据</strong> == </p><p><img src="/images/image-20220311150103265.png" alt="image-20220311150103265"></p><p>1</p><p><img src="/images/image-20220311152913379.png" alt="image-20220311152913379"></p><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><p><img src="/images/image-20220311153153960.png" alt="image-20220311153153960"></p><p><img src="/images/image-20220311154823492.png" alt="image-20220311154823492"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查询表的索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br><span class="line">#<span class="keyword">show</span> index <span class="keyword">from</span> tb_user\G; 以列的形式展示</span><br><span class="line">#创建索引  默认B<span class="operator">+</span> tree 索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name); </span><br><span class="line">#创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line">#创建联合索引 ?</span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br><span class="line">#email</span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><p>要SQL优化，主要优化查询语句</p><p><img src="/images/image-20220311160304177.png" alt="image-20220311160304177"></p><p><img src="/images/image-20220311160350991.png" alt="image-20220311160350991"></p><p><strong>上表查询为主</strong></p><p><img src="/images/image-20220311160642936.png" alt="image-20220311160642936"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220311160839076.png" alt="image-20220311160839076"></p><p> 慢查询日志</p><p><img src="/images/image-20220311161440182.png" alt="image-20220311161440182"></p><p><img src="/images/image-20220311161259562.png" alt="image-20220311161259562"></p><p><img src="/images/image-20220311161805944.png" alt="image-20220311161805944"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看profiling是否开启了对应的开关</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220311162051192.png" alt="image-20220311162051192"></p><p><img src="/images/image-20220311162425720.png" alt="image-20220311162425720"></p><p><strong>explain执行计划</strong></p><p><img src="/images/image-20220311205042667.png" alt="image-20220311205042667"></p><p> <img src="/images/image-20220311221310056.png" alt="image-20220311221310056"></p><p><img src="/images/image-20220313190200415.png" alt="image-20220313190200415"></p><p><img src="/images/image-20220313185722666.png" alt="image-20220313185722666"></p><img src="/images/image-20220313185945811.png" alt="image-20220313185945811" style="zoom:50%;" /><p>type值为null性能最好，一般通过主键访问会出现const ，对非唯一的索引会出现ref，在优化sql语句的时候尽量把type往前优化。如果出现all代表选表扫描性能会比较低，如果出现index说明用了索引，但是也会对索引进行扫描遍历 </p><p><img src="/images/image-20220313191006132.png" alt="image-20220313191006132"></p><p><img src="/images/image-20220313190455949.png" alt="image-20220313190455949"></p><p><img src="/images/image-20220313191129592.png" alt="image-20220313191129592"></p><p><img src="/images/image-20220313191227263.png" alt="image-20220313191227263"></p><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><p><img src="/images/image-20220313192032932.png" alt="image-20220313192032932"></p><p>在没有对sn字段创建索引之前，由于是千万级的数据，查询操作话费了20s左右，创建索引花了1分11秒左右之后，再次执行相同的对sn的查询操作，执行时间0.00s</p><p><img src="/images/image-20220313192305970.png" alt="image-20220313192305970"></p><p><img src="/images/image-20220313192958219.png" alt="image-20220313192958219"></p><p>前三条语句满足最左前缀法则，第四、 五条语句不满足最左前缀法则 </p><p><img src="/images/image-20220313193212882.png" alt="image-20220313193212882"></p><p>根据key_len对比发现，profession走了索引，status没有走索引。部分失效了 </p><p><img src="/images/image-20220313193444949.png" alt="image-20220313193444949"></p><p>这种情况下，索引都生效了，为什么呢？最左前缀法则指的是索引中的最左边的字段必须存在 ，跟放的位置是没有关系的</p><p><img src="/images/image-20220313194125621.png" alt="image-20220313194125621"></p><p><img src="/images/image-20220313193830361.png" alt="image-20220313193830361"></p><p>对比key_len可以发现，status是没有走索引的，是因为age使用了范围查询，范围查询右边的列索引将会失效 </p><p><img src="/images/image-20220313194023718.png" alt="image-20220313194023718"></p><p>对比key_len可以发现，联合索引都用上了，如果业务允许的情况下，尽量使用≥这样的 </p><p><strong>索引失效情况</strong></p><p><img src="/images/image-20220313194514251.png" alt="image-20220313194514251"></p><p><img src="/images/image-20220313194423165.png" alt="image-20220313194423165"></p><p><img src="/images/image-20220313194723975.png" alt="image-20220313194723975"></p><p><img src="/images/image-20220313194636086.png" alt="image-20220313194636086"></p><p><img src="/images/image-20220313194901332.png" alt="image-20220313194901332"></p><p><img src="/images/image-20220313194832319.png" alt="image-20220313194832319"></p><p><img src="/images/image-20220313195258996.png" alt="image-20220313195258996"></p><p><img src="/images/image-20220313195237699.png" alt="image-20220313195237699"></p><p><img src="/images/image-20220313195833227.png" alt="image-20220313195833227"></p><p>一般情况下，如果大多数数据满足情况，那么走全表（适用以上的语句</p><p><img src="/images/image-20220313195647822.png" alt="image-20220313195647822"></p><p><img src="/images/image-20220313200056429.png" alt="image-20220313200056429"></p><p>下面不走索引，因为绝大多数为notnull，</p><p>取决于当前这个数据库表结构的数据分布情况 </p><p><strong>SQL提示</strong></p><p><img src="/images/image-20220313200832243.png" alt="image-20220313200832243"></p><p><img src="/images/image-20220313201117026.png" alt="image-20220313201117026"></p><p><img src="/images/image-20220313201152541.png" alt="image-20220313201152541"></p><p><img src="/images/image-20220313201915536.png" alt="image-20220313201915536"></p><p><strong>using where using index 性能高，using index condition性能低</strong></p><p>上面的查询1使用到的索引是二级索引，而这个二级索引中，有id、profession、age、status，查询1不需要回表</p><p>而查询2有字段name，需要回表到聚集索引中查询</p><p><img src="/images/image-20220313202043002.png" alt="image-20220313202043002"></p><p><img src="/images/image-20220313202957726.png" alt="image-20220313202957726"></p><p><img src="/images/image-20220313203050352.png" alt="image-20220313203050352"></p><p>gender超出了覆盖索引的字段，所以我们先要扫描辅助索引，再去扫描聚集索引。</p><p>使用select * 很容易出现回表查询，除非创建了一个联合索引，这个联合索引包含了这张表的所有字段。</p><p><img src="/images/image-20220316172330887.png" alt="image-20220316172330887"></p><p><strong>对与username和password建立联合索引，由于二级索引下面挂的是id，所以不需要回表查询，直接覆盖索引</strong></p><p><strong>MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)</strong></p><p><img src="/images/image-20220316172947625.png" alt="image-20220316172947625"></p><p>​             <img src="/images/image-20220316173227121.png" alt="image-20220316173227121"></p><p><img src="/images/image-20220316173246644.png" alt="image-20220316173246644"></p><p>如果说选择性尽可能高，那就取10个前缀。如果要去平衡选择性和索引的前缀（索引的体积），那么可以选择5个前缀</p><p><img src="/images/image-20220316173535141.png" alt="image-20220316173535141"></p><p>取5个前缀的email的sub_part为5</p><p><img src="/images/image-20220316173702610.png" alt="image-20220316173702610"></p><p>因为前5个字符区分度已经比较高了，所以我们用5个字符来构建辅助索引</p><p>下面总结一下什么情况下使用前缀索引：</p><ul><li><p>字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’</p></li><li><p>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</p></li><li><p>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</p><p><img src="/images/image-20220316193244089.png" alt="image-20220316193244089"></p><p><img src="/images/image-20220316193139491.png" alt="image-20220316193139491"></p></li></ul><p>上面看Extra字段，上面是NULL需要回表查询，下面不需要</p><p>**在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引 **</p><p><img src="/images/image-20220316193436707.png" alt="image-20220316193436707"></p><p><img src="/images/image-20220316193544012.png" alt="image-20220316193544012"></p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p><img src="/images/image-20220316194452428.png" alt="image-20220316194452428"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220316194842323.png" alt="image-20220316194842323"></p><p><strong>执行频次：判定当前数据库是插入为主还是更新为主还是删除为主还是查询为主，我们主要针对查询频次比较高的数据库进行优化</strong></p><p><strong>慢查询日志：可以辨认出哪些sql语句执行比较耗时，只会记录执行时间超过了预设时间的sql</strong></p><p><strong>Profile：监控每一条语句的耗时，以及具体的时间耗费在哪一个阶段</strong></p><p><strong>explain：通过explain查看sql语句的执行计划，来评判sql语句的性能</strong></p><p>**联合索引：最左前缀法则，最左边的列必须存在，如果最左边的列不存在，整个联合索引都失效了 **</p><p><strong>索引失效：不要在索引列上进行函数运算，否则索引失效；字符串不加引号，会造成隐式类型转换，会造成索引失效；like模糊匹配，%加在前面；or连接的条件，如果一个有索引，一个没有索引；如果mysql评估走全表扫描比走索引还快，那么索引也会失效（数据分布的影响）；</strong></p><p><strong>SQL提示：我们在执行select语句的时候，如果有很多的索引，那么MySQL会根据它内部的策略来选择使用哪个索引，我们也可以给MySQL一些提示，告诉它你要用哪个索引，忽略哪个索引，强制使用哪个索引。</strong></p><p><strong>覆盖索引：查询返回的列在索引结构中都包含了，不需要回表查询了</strong></p><p><strong>回表查询：我们在查询的时候先走二级索引，先检索到这一行数据的id，再根据id再到聚集索引中再查找这一行的数据</strong></p><p><strong>前缀索引：当遇到字符串前缀较长，或者是大文本的时候，我们可以针对它建立前缀索引来缩小索引的体积，提高检索效率</strong></p><p><strong>单列/联合索引：推荐使用联合索引，因为联合索引性能较高；如果联合索引使用得当，可以避免回表查询</strong></p><p><strong>索引设计原则：1.我需要针对于哪些表来设计索引？（数据量大，而且查询频率较高）2.我需要针对于这些表的哪些字段建立索引（经常在where、orderby、groupby之后出现的字段来建立对应的索引）</strong></p><p><img src="/images/image-20220321114110586.png" alt="image-20220321114110586"></p><p><strong>如果这一列是唯一的，那尽量建立唯一索引；如果能建立联合索引，尽量使用联合索引；如果涉及到一些字符串长度较长，或者是大本文字段，我们尽量使用前缀索引。</strong></p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p><img src="/images/image-20220321133542103.png" alt="image-20220321133542103"></p><p>批量插入时建议一次不要插入超过1000条数据，可以分批批量插入 </p><p><strong>主键顺序插入的性能要高于乱序插入</strong></p><p> <strong>–local infile 表示需要去加载本地的文件</strong></p><p><img src="/images/image-20220321133836953.png" alt="image-20220321133836953"></p><p><strong>每个元素之间使用”,”分隔，每一行之间使用”\n”分隔</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@local</span>_infile #查看开关是否开启，默认是关闭的</span><br><span class="line">#开启</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p><img src="/images/image-20220321134609563.png" alt="image-20220321134609563"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l load_user_100w_sort.sql #查看有多少行</span><br><span class="line">head load_user_100w_sort.sql #查看前面几行数据详情</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p><img src="/images/image-20220321135258031.png" alt="image-20220321135258031"></p><p> <img src="/images/image-20220321135828933.png" alt="image-20220321135828933"></p><p> <img src="/images/image-20220321140030238.png" alt="image-20220321140030238"></p><p><img src="/images/image-20220321140224765.png" alt="image-20220321140224765"></p><p><strong>当如上图情况发生的时候，开启一个新的数据页，元素50不会直接写到3#page上，找到1#page50%的位置，把23、47移动到新开启的数据页上，再将50插入到page3里，所以1号数据页指针下一个指向3了，需要对链表指针进行一个重新的设置。</strong></p><p><img src="/images/image-20220321140549668.png" alt="image-20220321140549668"></p><p>  <img src="/images/image-20220321140841426.png" alt="image-20220321140841426"></p><p><img src="/images/image-20220321140857458.png" alt="image-20220321140857458"></p><p><strong>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</strong></p><p><strong>为什么要降低主键的长度？</strong></p><p><strong>聚集索引只有一个，而二级索引有很多个，而在二级索引的叶子结点上，挂的就是主键。索引如果主键索引比较长，二级索引比较多，就会占用大量的磁盘空间。而且在搜索的时候会耗费大量的磁盘io。</strong></p><p><img src="/images/image-20220321202821939.png" alt="image-20220321202821939"></p><p><strong>uid、身份证之类的字段太长而且乱序。</strong></p><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p><img src="/images/image-20220321204028555.png" alt="image-20220321204028555"></p><p><strong>没有创建联合索引：using filesort</strong></p><p><strong>创建了联合索引：using index</strong></p><p><img src="/images/image-20220321204459840.png" alt="image-20220321204459840"></p><p><strong>反向扫描索引</strong></p><p><img src="/images/image-20220321204557080.png" alt="image-20220321204557080"></p><p><strong>因为创建索引的时候age是第一个字段，而在排序的时候phone是第一个字段，违背了最左前缀法则</strong></p><p><img src="/images/image-20220321204744263.png" alt="image-20220321204744263"></p><p><strong>出现这种情况的原因是：在创建索引的时候，如果没有指定顺序，默认是按照升序走的。</strong></p><p><strong>针对这个问题：</strong><img src="/images/image-20220321205108587.png" alt="image-20220321205108587"></p><p><img src="/images/image-20220321205143406.png" alt="image-20220321205143406"></p><p><strong>不会出现filesort了</strong></p><p><img src="/images/image-20220321205434838.png" alt="image-20220321205434838"></p><p><img src="/images/image-20220321205903064.png" alt="image-20220321205903064"> </p><p><img src="/images/image-20220321205808993.png" alt="image-20220321205808993"></p><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p><img src="/images/image-20220321211707870.png" alt="image-20220321211707870"></p><p>**用到了临时表，性能是比较低的 **   </p><p><img src="/images/image-20220321211915310.png" alt="image-20220321211915310"></p><p>**下面满足最左前缀法则，所以走索引  **</p><p><img src="/images/image-20220321212027369.png" alt="image-20220321212027369"></p><p><strong>满足最左前缀法则，where后面跟了prefession groupby后跟了age</strong></p><p><img src="/images/image-20220321212122375.png" alt="image-20220321212122375"></p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p><img src="/images/image-20220321212627081.png" alt="image-20220321212627081"></p><p>**不支持子查询重的limit操作，采用多表联查  **</p><p><img src="/images/image-20220321212823263.png" alt="image-20220321212823263"></p><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><img src="/images/image-20220321213920682.png" alt="image-20220321213920682"></p><p><img src="/images/image-20220321214208373.png" alt="image-20220321214208373"></p><p><strong>表中null值的情况，因为计数的每一行是不是null，所以为0</strong></p><p><img src="/images/image-20220321215349798.png" alt="image-20220321215349798"></p><p><strong>遇到计数不是null就加1</strong></p><p><img src="/images/image-20220321215652834.png" alt="image-20220321215652834"></p><p><img src="/images/image-20220321215708810.png" alt="image-20220321215708810"></p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p><img src="/images/image-20220322160227742.png" alt="image-20220322160227742"></p><p>**在执行更新的时候，更新的条件一定要有索引，如果没有索引，那么行锁会升级为表锁  **</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220322161154294.png" alt="image-20220322161154294"></p><h2 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图/存储过程/触发器"></a>视图/存储过程/触发器</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><img src="/images/image-20220322161809406.png" alt="image-20220322161809406"></p><p><img src="/images/image-20220322162750139.png" alt="image-20220322162750139"></p><p><img src="/images/image-20220322163033901.png" alt="image-20220322163033901"></p><p><img src="/images/image-20220322165836343.png" alt="image-20220322165836343"></p><p><img src="/images/image-20220322170054942.png" alt="image-20220322170054942"></p><p><strong>v1插入id为6和30都能成功，因为没有加with check option</strong></p><p><img src="/images/image-20220322170458955.png" alt="image-20220322170458955"></p><p><strong>v2插入id为7和26的数据都无法成功，插入15能成功</strong></p><p><img src="/images/image-20220322170635683.png" alt="image-20220322170635683"></p><p><strong>11，17成功28失败，v3的插入条件继承与v2，17能成功也是因为没有加with check option</strong></p><p><img src="/images/image-20220322171557328.png" alt="image-20220322171557328"></p><p><strong>由于v4没有约束，于是插入id为5和16的数据都能成功</strong></p><p><strong>v5有约束，但是事local约束，id为13和17（与v4的≤15无关）都能插入成功</strong></p><p><strong>如果v4加入了local检查，那么v5插入id为18的数据将会失败</strong></p><p><strong>v6插入id为14的字段成功</strong></p><p><img src="/images/image-20220322172051395.png" alt="image-20220322172051395"></p><p><img src="/images/image-20220322172516771.png" alt="image-20220322172516771"></p><p><img src="/images/image-20220322173142745.png" alt="image-20220322173142745"></p><p><strong>数据独立：假如说主表的字段名发生变化，则可以通过视图的调整屏蔽影响，主表name-&gt;studentName,视图select studentName as name</strong></p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p><img src="/images/image-20220323132744302.png" alt="image-20220323132744302"></p><p> <img src="/images/image-20220323132903277.png" alt="image-20220323132903277"></p><p> <img src="/images/image-20220323133210352.png" alt="image-20220323133210352"></p><p><img src="/images/image-20220323133830126.png" alt="image-20220323133830126"></p><p><img src="/images/image-20220323133903107.png" alt="image-20220323133903107"></p><p> <img src="/images/image-20220323134042860.png" alt="image-20220323134042860"></p><p> <img src="/images/image-20220323133710679.png" alt="image-20220323133710679"></p><p><strong>DEFINER字段不指定的话会默认加上</strong></p><p><strong>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符</strong>、</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220323135527638.png" alt="image-20220323135527638"></p><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a><strong>系统变量</strong></h4><p> <img src="/images/image-20220324125027263.png" alt="image-20220324125027263"></p><p><strong>session只代表的是当前会话，不会影响到其他会话</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#设置系统变量 </span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">0</span>; #不自动提交</span><br></pre></td></tr></table></figure><p><strong>设置了全局级别的参数所有的会话都会生效，但是当服务器重启之后</strong></p><p><img src="/images/image-20220324134333606.png" alt="image-20220324134333606"> </p><h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a><strong>用户变量</strong></h4><p><img src="/images/image-20220324134708642.png" alt="image-20220324134708642"></p><p><strong>推荐使用:= 因为在mysql中=既可以作为赋值运算符，又可以作为比较运算符</strong></p><p><img src="/images/image-20220324135123270.png" alt="image-20220324135123270"></p><p><strong>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</strong></p><p><strong>比如直接select @abc;结果为null（没有定义abc变量</strong></p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h4><p> <img src="/images/image-20220324135730291.png" alt="image-20220324135730291"></p><p><img src="/images/image-20220324135956745.png" alt="image-20220324135956745"></p><p><strong>1.创建一个存储过程。2.声明局部变量。3.赋值。4.查询。5.调用存储过程。</strong></p><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p><img src="/images/image-20220324140508738.png" alt="image-20220324140508738"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">if score <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">elseif score <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> p3();</span><br><span class="line">#不及格</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><img src="/images/image-20220324141044272.png" alt="image-20220324141044272"></p><p><img src="/images/image-20220324145050721.png" alt="image-20220324145050721"></p><p>  <img src="/images/image-20220324145358704.png" alt="image-20220324145358704"></p><p><img src="/images/image-20220324145432246.png" alt="image-20220324145432246"></p><p><img src="/images/image-20220324145443285.png" alt="image-20220324145443285"></p><p> <img src="/images/image-20220324170316549.png" alt="image-20220324170316549"></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p><img src="/images/image-20220324170449743.png" alt="image-20220324170449743"></p><p><img src="/images/image-20220324170737857.png" alt="image-20220324170737857"></p><p><img src="/images/image-20220324170957272.png" alt="image-20220324170957272"></p><p>end;</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p><img src="/images/image-20220324171213030.png" alt="image-20220324171213030"></p><p><img src="/images/image-20220324171314483.png" alt="image-20220324171314483"></p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p><img src="/images/image-20220324171750899.png" alt="image-20220324171750899"></p><p><img src="/images/image-20220324171950311.png" alt="image-20220324171950311"></p><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p><img src="/images/image-20220324203642566.png" alt="image-20220324203642566"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#loop 计算从<span class="number">1</span>累加到n的值，n为传入的参数值</span><br><span class="line">#A 定义局部变量，记录累加之后的值</span><br><span class="line">#B 每循环一次，就会对n进行<span class="number">-1</span>，如果n减到<span class="number">0</span>，则退出循环<span class="comment">----&gt;leave xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum:loop</span><br><span class="line">if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">leave sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> loop sum;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">#loop 计算从<span class="number">1</span>到n之间的偶数累加的值，n为传入的参数值</span><br><span class="line">#A 定义局部变量，记录累加之后的值</span><br><span class="line">#B 每循环一次，就会对n进行<span class="number">-1</span>，如果n减到<span class="number">0</span>，则退出循环<span class="comment">----&gt;leave xx</span></span><br><span class="line">#C 如果当次累加的数据是奇数，则直接进入下一次循环<span class="comment">----&gt;iterate xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum:loop</span><br><span class="line">if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">leave sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line">if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">iterate sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> loop sum;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标-cursor"></a>游标-cursor</h4><p><img src="/images/image-20220324205333342.png" alt="image-20220324205333342"></p><p><img src="/images/image-20220324205444825.png" alt="image-20220324205444825"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#A 声明游标，存储查询结果集</span><br><span class="line">#B 准备：创建表结构</span><br><span class="line">#C 开启游标</span><br><span class="line">#D 获取游标中的记录</span><br><span class="line">#E 插入数据到新表中</span><br><span class="line">#F 关闭游标</span><br><span class="line">#要声明普通变量，再声明游标</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">      id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">      profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>,uname,upro); #id自增采用<span class="keyword">null</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    #循环体这么写会报错，[<span class="number">02000</span>][<span class="number">1329</span>]<span class="keyword">No</span> data <span class="operator">-</span> zero <span class="keyword">rows</span> fetched,selected,<span class="keyword">or</span> processed,因为while <span class="literal">true</span> 会一直执行下去</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="条件处理程序-handler"><a href="#条件处理程序-handler" class="headerlink" title="条件处理程序-handler"></a>条件处理程序-handler</h4><p><img src="/images/image-20220324211929100.png" alt="image-20220324211929100"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">#<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">close</span> u_cursor;</span><br><span class="line">#声明一个条件处理程序，当满足<span class="keyword">sql</span>状态码为<span class="number">02000</span>时触发，触发退出操作，将游标关闭掉 ，执行不会报错</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">      id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">      profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    ); </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>,uname,upro); #id自增采用<span class="keyword">null</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p><img src="/images/image-20220325135333518.png" alt="image-20220325135333518"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fun1(n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">select</span> fun1(<span class="number">100</span>);#调用</span><br></pre></td></tr></table></figure><p><strong>存储函数用的比较少一点，因为存储函数能做的事情，存储过程也能做，存储函数必须要用返回值，存储过程可以设定参数的类型为out，就可以接收我存储过程执行的结果</strong></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p><img src="/images/image-20220325140232011.png" alt="image-20220325140232011"></p><p><strong>如果执行update型触发器影响了5行，触发器触发了5次，则称之为行级触发器，语句触发器指执行update，不管影响了多少行，只触发一次，那就是语句型触发器</strong></p><p><img src="/images/image-20220325140720034.png" alt="image-20220325140720034"></p><p><img src="/images/image-20220325141223803.png" alt="image-20220325141223803"></p><p>  <img src="/images/image-20220325141825320.png" alt="image-20220325141825320"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">VALUES</span></span><br><span class="line">#<span class="keyword">new</span>表示将要或者已经新增的数据</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.email,<span class="string">&#x27;,profession=&#x27;</span>,new.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"><span class="comment">-- 删除指定的触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br><span class="line"><span class="comment">-- 插入数据到tb_user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看日志表 user_logs</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">VALUES</span></span><br><span class="line">#<span class="keyword">new</span>表示将要或者已经修改后的数据</span><br><span class="line">#<span class="keyword">old</span>表示修改之前的数据</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;更新之前的数据为：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.email,<span class="string">&#x27;,profession=&#x27;</span>,old.profession,</span><br><span class="line">     <span class="string">&#x27;更新之后的数据为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.email,<span class="string">&#x27;,profession=&#x27;</span>,new.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"># 行级触发器</span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> profession <span class="operator">=</span> <span class="string">&#x27;会计&#x27;</span> <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">VALUES</span></span><br><span class="line">#<span class="keyword">old</span>表示删除之前的数据</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.email,<span class="string">&#x27;,profession=&#x27;</span>,old.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220325165240966.png" alt="image-20220325165240966"></p><h2 id="锁🔒"><a href="#锁🔒" class="headerlink" title="锁🔒"></a>锁🔒</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/image-20220325165648051.png" alt="image-20220325165648051"></p><p><img src="/images/image-20220325165753503.png" alt="image-20220325165753503"></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p><img src="/images/image-20220325171053195.png" alt="image-20220325171053195"></p><p><strong>加了全局锁之后：其他客户端不能执行数据操纵、数据删除，可以查询，整个过程中通过全局锁来解决全库的逻辑备份，从而保证逻辑备份的数据的一致性和完整性。</strong></p><p><img src="/images/image-20220325171236636.png" alt="image-20220325171236636"></p><p><strong>语法</strong></p><p><img src="/images/image-20220325171558878.png" alt="image-20220325171558878"></p><p><strong>逻辑备份之前加锁，逻辑备份之后去掉锁</strong></p><p><img src="/images/image-20220325172004445.png" alt="image-20220325172004445"></p><p> <img src="/images/image-20220325172309161.png" alt="image-20220325172309161"></p><p>**在mysql innoDB的底层实际上是通过快照读来实现的 **</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p> <img src="/images/image-20220325172731627.png" alt="image-20220325172731627"></p><p><img src="/images/image-20220325174320063.png" alt="image-20220325174320063"></p><p><strong>会阻塞直到另一个客户端的表锁的释放</strong></p><p><strong>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</strong></p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p><img src="/images/image-20220325175021695.png" alt="image-20220325175021695"></p><p><img src="/images/image-20220325175223961.png" alt="image-20220325175223961"></p><p><strong>此时右边阻塞，why？</strong></p><p><strong>因为当前有未提交的事务，在这个未提交的事务中，执行了select语句，自动加上了SHARED_READ锁，而右边使用了alter，就要对对应的表加上排他锁，排他锁与其他的锁互斥，阻塞到左侧事务提交</strong></p><p><img src="/images/image-20220325194656934.png" alt="image-20220325194656934"></p><p><img src="/images/image-20220325194933185.png" alt="image-20220325194933185"></p><p><strong>执行了select、update出现了两种锁</strong></p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p><img src="/images/image-20220325195745751.png" alt="image-20220325195745751"></p><p><img src="/images/image-20220325195923752.png" alt="image-20220325195923752"></p><p><img src="/images/image-20220325200506826.png" alt="image-20220325200506826"></p><p><strong>当执行update语句的时候，会给相应的行加上行锁，也会自动给表加上意向锁</strong></p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p><img src="/images/image-20220325205228752.png" alt="image-20220325205228752"></p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="/images/image-20220325205610571.png" alt="image-20220325205610571"></p><p><img src="/images/image-20220325205743794.png" alt="image-20220325205743794"></p><p><img src="/images/image-20220325205902299.png" alt="image-20220325205902299"></p><p><img src="/images/image-20220325210226248.png" alt="image-20220325210226248"></p><p><strong>共享锁与共享锁之间是兼容的</strong></p><p><img src="/images/image-20220325210530443.png" alt="image-20220325210530443"></p><p><strong>此时处于阻塞状态，是因为我们在更新的时候name是没有索引的，就会升级为表锁</strong></p><h4 id="间隙锁-临界锁"><a href="#间隙锁-临界锁" class="headerlink" title="间隙锁/临界锁"></a>间隙锁/临界锁</h4><p><img src="/images/image-20220325210727995.png" alt="image-20220325210727995"></p><p>  <img src="/images/image-20220325211407097.png" alt="image-20220325211407097"></p><p><strong>表示锁了3和8之间的间隙，插入id为7的数据会阻塞，防止幻读</strong></p><p> <img src="/images/image-20220325211610433.png" alt="image-20220325211610433"></p><p><strong>对于普通索引，18之前可能插入一个字段值为18的记录，18之后也有可能，对18-29之间的这段间隙，以及18之前的这段间隙加锁。</strong></p><p><img src="/images/image-20220325212116105.png" alt="image-20220325212116105"></p><p><strong>临界锁</strong></p><p><img src="/images/image-20220325212457395.png" alt="image-20220325212457395"></p><p><strong>当我们执行这条语句的时候，也就意味着会把19这行的行锁锁住，然后加了个临界锁锁的是25这行记录，与25之前的间隙，还有个临界锁锁的是正无穷大以及正无穷到25之间的间隙</strong></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/image-20220325212932671.png" alt="image-20220325212932671"></p><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p><strong>表结构中所存储的记录以及索引都是在页这个逻辑结构中存储的</strong></p><p><img src="/images/image-20220325214819427.png" alt="image-20220325214819427"></p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="/images/image-20220325215009205.png" alt="image-20220325215009205"></p><p> <img src="/images/image-20220325220519853.png" alt="image-20220325220519853"></p><p>**当缓冲池里面的数据改了，但是磁盘中的数据还没有改，因为缓冲区的数据还没有刷新到磁盘上，所以这一类型的页称之为脏页  **</p><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构 "></a>内存架构 <img src="/images/image-20220327104455840.png" alt="image-20220327104455840"></h4><p><strong>自适应哈希适用于等值匹配，不适用于范围查询</strong> </p><p><img src="/images/image-20220327105312507.png" alt="image-20220327105312507"></p><p><img src="/images/image-20220327105534332.png" alt="image-20220327105534332"></p><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="/images/image-20220328172520740.png" alt="image-20220328172520740"></p><p>  <img src="/images/image-20220328175018469.png" alt="image-20220328175018469"></p><p> <img src="/images/image-20220328175227276.png" alt="image-20220328175227276"></p><p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0 ib_logfile1  </p><p><strong>后台线程</strong></p><p><img src="/images/image-20220328180324620.png" alt="image-20220328180324620"></p><p>**对于innodb的整个体系结构，当我们业务在操作的时候，那么会直接去操作缓冲区，如果缓冲区当中没有数据，会将磁盘当中的数据加载回来，然后再存储在缓冲区当中 。我们在增删改查的时候都会去操作缓冲区，缓冲区当中的数据会以一定的频率/时机要通过后台线程刷新到磁盘当中，然后在磁盘当中永久化的保存下来。 **</p><h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><p><img src="/images/image-20220328200653586.png" alt="image-20220328200653586"></p><p><strong>原子性、一致性、持久性是由redo log、undo log实现的</strong></p><p><strong>隔离性是由锁和MVCC实现的</strong></p><h5 id="持久性的保证"><a href="#持久性的保证" class="headerlink" title="持久性的保证"></a>持久性的保证</h5><p><strong>具体的操作流程</strong></p><p>首先，客户端在进行事务操作时会发起请求来操作我们的mysql服务器，在mysql服务器的innodb引擎中，分为内存结构和磁盘结构，磁盘结构里存放来很多的数据文件，内存结构中有很大的一块区域（buffer pool），在缓冲池中缓冲了我们一个个的数据页的信息。当我们进行update执行的时候，要去操作缓冲区，在缓冲区中要去查找，有没有我们所更新的这一块数据，如果没有，此时会通过后台线程把数据，从磁盘当中读取出来，然后缓存在缓冲区当中。那接下来就可以直接执行更新以及删除的操作，直接去操作缓冲区当中的数据 。 直接操作缓冲区的数据，磁盘中的数据没有更新，那这个时候就出现了脏页。脏页要在一定的时机通过后台线程刷新到磁盘当中。但脏页的数据并不是实时刷新的，而是一段时间之后，通过后台线程把脏页的数据刷新到磁盘当中。假如说脏页的数据在往磁盘结构中进行刷新的时候出错了，那么此时，我们内存中的数据没有刷新到磁盘当中，可是事务已经提交了，也告诉了用户事务提交成功了，但是最终在脏页刷新的时候失败了。<strong>那这时候持久性就没有得到保障</strong>。</p><p><strong>redolog重做日志出现之后的流程：</strong></p><p>当我们对缓冲区当中的数据进行了增删改之后，首先会把增删改的数据记录在redolog buffe中，在redolog buffer中又会去记录数据页的物理变化，当我们事务在提交的时候，会把redolog buffer中的数据页变化刷新到磁盘中 ，实体化得保存在磁盘文件上。再过一段时间后，在进行脏页刷新的时候，假如说出错了，可以通过redolog进行恢复。</p><p><strong>为什么在进行提交的时候要把redolog刷新到磁盘中？</strong></p><p>如果每一次提交的时候，不需要redolog，直接把bufferpool中的数据刷新到磁盘文件中，存在严重的性能问题。我们一般在事务中进行一组操作的时候，通常来说会操作很多条记录，而这些记录都是随机地去操作数据页，那么这个时候就会涉及到大量的随机磁盘io，性能比较低。如果用到了redolog，在事务提交时不会把脏页直接刷新，先把redolog文件刷新到磁盘中，由于是log日志文件，日志文件都是追加的，那么此时就是顺序磁盘io， 那么性能就是高于随机磁盘io的，这种机制叫做WAL。写入日志之后，再将脏页的数据刷新到磁盘中，如果说脏页的数据顺利的刷新到磁盘中了，那么此时redolog记录的数据变更也就不需要了，所以每隔一段时间就会去清理redolog，所以两份日志是循环使用的。</p><p><img src="/images/image-20220328210111465.png" alt="image-20220328210111465"></p><p><strong>redolog就是为了保证在进行脏页刷新发生错误时进行数据恢复，从而保证事务的持久性。</strong></p><h5 id="原子性的保证"><a href="#原子性的保证" class="headerlink" title="原子性的保证"></a>原子性的保证</h5><p><img src="/images/image-20220328212335339.png" alt="image-20220328212335339"></p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p><img src="/images/image-20220328213044947.png" alt="image-20220328213044947"></p><p><img src="/images/image-20220328213401564.png" alt="image-20220328213401564"></p><p><strong>查看ibd文件： ibd2sdi stu.ibd</strong></p><p><img src="/images/image-20220328214100687.png" alt="image-20220328214100687"></p><p><img src="/images/image-20220328215032714.png" alt="image-20220328215032714"></p><p> <img src="/images/image-20220328215625704.png" alt="image-20220328215625704"></p><p> <img src="/images/image-20220328220040423.png" alt="image-20220328220040423"></p><p><img src="/images/image-20220328220059165.png" alt="image-20220328220059165"></p><p>   <img src="/images/image-20220328220827833.png" alt="image-20220328220827833"></p><p><strong>事务5的第一次快照读结果为0x00002</strong></p><p><strong>第二次快照读的结果为0x00003</strong></p><p><img src="/images/image-20220328221225426.png" alt="image-20220328221225426"></p><p><img src="/images/image-20220328221328616.png" alt="image-20220328221328616"></p><p><strong>mvcc作用就是在进行快照读的时候要通过mvcc来查找对应的历史版本</strong></p><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><img src="/images/image-20220329134640470.png" alt="image-20220329134640470"></p><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><img src="/images/image-20220329135437788.png" alt="image-20220329135437788"></p><p><img src="/images/image-20220329135535284.png" alt="image-20220329135535284"></p><p><img src="/images/image-20220329145437109.png" alt="image-20220329145437109"></p><p><img src="/images/image-20220329145740151.png" alt="image-20220329145740151"></p><p><img src="/images/image-20220329150245518.png" alt="image-20220329150245518"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p1234 db01 &gt; db01.sql </span><br></pre></td></tr></table></figure><p><img src="/images/image-20220329150801611.png" alt="image-20220329150801611"></p><p><strong>db02明显比db01小</strong></p><p><img src="/images/image-20220329151241341.png" alt="image-20220329151241341"></p><p><strong>去找mysql信任的目录</strong></p><p><img src="/images/image-20220329151345637.png" alt="image-20220329151345637"></p><p><img src="/images/image-20220329151456939.png" alt="image-20220329151456939"></p><p><img src="/images/image-20220329151615843.png" alt="image-20220329151615843"></p><p><img src="/images/image-20220329151759186.png" alt="image-20220329151759186"></p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220329152039341.png" alt="image-20220329152039341"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/image-20220305154604127.png&quot; alt=&quot;image-20220305</summary>
      
    
    
    
    
    <category term="数据库" scheme="https://lzjzzzzzzz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>About me</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/17/mee/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/17/mee/</id>
    <published>2022-04-17T12:41:02.000Z</published>
    <updated>2022-04-17T13:01:59.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找不到实习啊啊啊啊！！！"><a href="#找不到实习啊啊啊啊！！！" class="headerlink" title="找不到实习啊啊啊啊！！！"></a>找不到实习啊啊啊啊！！！</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;找不到实习啊啊啊啊！！！&quot;&gt;&lt;a href=&quot;#找不到实习啊啊啊啊！！！&quot; class=&quot;headerlink&quot; title=&quot;找不到实习啊啊啊啊！！！&quot;&gt;&lt;/a&gt;找不到实习啊啊啊啊！！！&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/17/hello-world/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/17/hello-world/</id>
    <published>2022-04-17T08:56:15.313Z</published>
    <updated>2022-04-18T04:05:20.079Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="1212" scheme="https://lzjzzzzzzz.github.io/tags/1212/"/>
    
  </entry>
  
</feed>
