<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>什么时候能找到实习</title>
  
  
  <link href="https://lzjzzzzzzz.github.io/atom.xml" rel="self"/>
  
  <link href="https://lzjzzzzzzz.github.io/"/>
  <updated>2022-04-24T04:30:19.956Z</updated>
  <id>https://lzjzzzzzzz.github.io/</id>
  
  <author>
    <name>L1u</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多个数组求交集</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/24/leetcode01/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/24/leetcode01/</id>
    <published>2022-04-24T04:27:11.000Z</published>
    <updated>2022-04-24T04:30:19.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多个数组求交集"><a href="#多个数组求交集" class="headerlink" title="多个数组求交集"></a>多个数组求交集</h2><p>这道题让我体会到了C++和java做算法题的差距，c++真的方便很多。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : nums) <span class="keyword">for</span> (<span class="type">int</span> x : v) mp[x]++;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) <span class="keyword">if</span> (it-&gt;second == nums.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：TsReaper</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/circle/discuss/F9IBSj/view/1UdWuf/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>给你一个二维整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 是由 <strong>不同</strong> 正整数组成的一个非空数组，按 <strong>升序排列</strong> 返回一个数组，数组中的每个元素在 <code>nums</code> <strong>所有数组</strong> 中都出现过。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]</span><br><span class="line">输出：[3,4]</span><br><span class="line">解释：</span><br><span class="line">nums[0] = [3,1,2,4,5]，nums[1] = [1,2,3,4]，nums[2] = [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= sum(nums[i].length) &lt;= 1000</code></li><li><code>1 &lt;= nums[i][j] &lt;= 1000</code></li><li><code>nums[i]</code> 中的所有值 <strong>互不相同</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">intersection</span><span class="params">(<span class="type">int</span>[][] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Map &lt;Integer,Integer&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;nums[i].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(myMap.containsKey(nums[i][j])) &#123;</span><br><span class="line">                    myMap.put(nums[i][j],myMap.get(nums[i][j])+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    myMap.put(nums[i][j],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : myMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span>(value == nums.length) &#123;</span><br><span class="line">                res.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多个数组求交集&quot;&gt;&lt;a href=&quot;#多个数组求交集&quot; class=&quot;headerlink&quot; title=&quot;多个数组求交集&quot;&gt;&lt;/a&gt;多个数组求交集&lt;/h2&gt;&lt;p&gt;这道题让我体会到了C++和java做算法题的差距，c++真的方便很多。。&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
    <category term="leetcode" scheme="https://lzjzzzzzzz.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Java集合(一)</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/23/jihe1/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/23/jihe1/</id>
    <published>2022-04-23T15:19:12.000Z</published>
    <updated>2022-04-23T15:21:59.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合概述"><a href="#Java集合概述" class="headerlink" title="Java集合概述"></a>Java集合概述</h2><p>Java 集合可分为 Collection 和 Map 两种体系</p><ul><li><p>Collection<strong>接口：</strong>单列数据，定义了存取一组对象的方法的集合</p><p> List<strong>：</strong>元素有序、可重复的集合</p></li></ul><p>​        Set<strong>：</strong>元素无序、不可重复的集合</p><ul><li>Map<strong>接口：</strong>双列数据，保存具有映射关系“key-value对”的集合</li></ul><h3 id="Collection接口继承树"><a href="#Collection接口继承树" class="headerlink" title="Collection接口继承树"></a>Collection接口继承树</h3><p><img src="/images/image-20220423204358969.png" alt="image-20220423204358969"></p><h3 id="Map接口继承树"><a href="#Map接口继承树" class="headerlink" title="Map接口继承树"></a>Map接口继承树</h3><p><img src="/images/image-20220423204525047.png" alt="image-20220423204525047"></p><h2 id="Collection接口方法"><a href="#Collection接口方法" class="headerlink" title="Collection接口方法"></a>Collection接口方法</h2><table><thead><tr><th>add(Object obj)  addAll(Collection Coll)</th><th>添加元素</th></tr></thead><tbody><tr><td><strong>int size()</strong></td><td><strong>返回集合中元素个数</strong></td></tr><tr><td><strong>void clear()</strong></td><td><strong>清空集合</strong></td></tr><tr><td><strong>boolean isEmpty()</strong></td><td><strong>判断集合是否为空</strong></td></tr><tr><td><strong>boolean contains(Object obj)</strong></td><td><strong>是通过元素的equals方法来判断是否是同一个对象，需要重写类方法</strong></td></tr><tr><td><strong>boolean containsAll(Collection c)</strong></td><td><strong>拿两个集合的元素挨个比较是否包含集合c</strong></td></tr><tr><td><strong>boolean remove(Object obj)</strong></td><td><strong>通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</strong></td></tr><tr><td><strong>boolean removeAll(Collection coll)</strong></td><td><strong>取当前集合的差集</strong></td></tr><tr><td><strong>boolean retainAll(Collection c)</strong></td><td><strong>把交集的结果存在当前集合中，不影响c</strong></td></tr><tr><td><strong>Object[] toArray()</strong></td><td><strong>集合转成对象数组</strong></td></tr><tr><td><strong>boolean equals(Object obj)</strong></td><td><strong>逐个判断集合是否相等，List是有序的，所以碰到不相等的时候就返回false</strong></td></tr><tr><td><strong>hashCode()</strong></td><td><strong>获取集合对象的哈希值</strong></td></tr><tr><td><strong>iterator()</strong></td><td><strong>返回迭代器对象，用于集合遍历</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组---&gt;集合 调用Arrays类的静态方法asList()</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>,<span class="number">456</span>&#125;); <span class="comment">//size为1</span></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>,<span class="number">456</span>&#125;); <span class="comment">//size为2 ，包装类的对象</span></span><br></pre></td></tr></table></figure><h2 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h2><ul><li>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</li><li>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</li><li>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tomcat&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());//报异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        //方式二：不推荐</span></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; coll.size();i++) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式三：推荐</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220423223129192.png" alt="image-20220423223129192"></p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ul><li><p>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方 法，不是集合对象的remove方法。 </p></li><li><p>如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，再调用remove都会报IllegalStateException。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;Tomcat&quot;</span>.equals(obj)) &#123;</span><br><span class="line">    iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h3><ul><li><p> Java 5.0 提供了 foreach 循环迭代访问 Collection和数组。</p></li><li><p>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</p></li><li><p>遍历集合的底层调用Iterator完成操作。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for(集合元素类型 局部变量 : 集合对象)</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : coll) &#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java集合概述&quot;&gt;&lt;a href=&quot;#Java集合概述&quot; class=&quot;headerlink&quot; title=&quot;Java集合概述&quot;&gt;&lt;/a&gt;Java集合概述&lt;/h2&gt;&lt;p&gt;Java 集合可分为 Collection 和 Map 两种体系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Annotation(注解)</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/23/Annotation/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/23/Annotation/</id>
    <published>2022-04-23T09:10:10.000Z</published>
    <updated>2022-04-23T09:11:03.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解概述"><a href="#注解概述" class="headerlink" title="注解概述"></a>注解概述</h2><ul><li><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) </p></li><li><p>Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p></li><li><p>Annotation 可以像修饰符一样被使用, 可用于<strong>修饰包</strong>,<strong>类</strong>, <strong>构造器</strong>, <strong>方法</strong>, <strong>成员变量</strong>, <strong>参数</strong>, <strong>局部变量的声明</strong>, 这些信息被保存在 Annotation 的 “name=value” 对中。</p></li><li><p>注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 设计模式。</p></li></ul><h2 id="常见的注解示例"><a href="#常见的注解示例" class="headerlink" title="常见的注解示例"></a><strong>常见的注解示例</strong></h2><h3 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a><strong>示例一：生成文档相关的注解</strong></h3><p>@author 标明开发该类模块的作者，多个作者之间使用,分割</p><p>@version 标明该类模块的版本</p><p>@see 参考转向，也就是相关主题</p><p>@since 从哪个版本开始增加的</p><p>@param 对方法中某参数的说明，如果没有参数就不能写</p><p>@return 对方法返回值的说明，如果方法的返回值类型是void就不能写</p><p>@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写</p><p>其中</p><p>@param @return 和 @exception 这三个标记都是只用于方法的。</p><p>@param的格式要求：@param 形参名 形参类型 形参说明</p><p>@return 的格式要求：@return 返回值类型 返回值说明</p><p>@exception的格式要求：@exception 异常类型 异常说明</p><p>@param和@exception可以并列多个</p><h3 id="示例二：在编译时进行格式检查-JDK内置的三个基本注解"><a href="#示例二：在编译时进行格式检查-JDK内置的三个基本注解" class="headerlink" title="示例二：在编译时进行格式检查(JDK内置的三个基本注解)"></a><strong>示例二：在编译时进行格式检查</strong>(JDK<strong>内置的三个基本注解</strong>)</h3><ul><li><p>@Override: 限定重写父类方法, 该注解只能用于方法</p></li><li><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p></li><li><p>@SuppressWarnings: 抑制编译器警告  #@SuppressWarnings(“unused”) </p></li></ul><h3 id="示例三：跟踪代码依赖性，实现替代配置文件功能"><a href="#示例三：跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="示例三：跟踪代码依赖性，实现替代配置文件功能"></a><strong>示例三：跟踪代码依赖性，实现替代配置文件功能</strong></h3><p>Spring框架等</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li><p>参照@SuppressWarning定义。</p></li><li><p>内部定义成员，通常使用value表示。</p></li><li><p>可以指定成员的默认值，使用default定义。</p></li><li><p>如果自定义注解没有成员，表明是一个标识作用。</p></li><li><p>如果注解有成员，在使用注解时，需要指明成员的值。</p></li><li><p><strong>注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义。</strong></p></li></ul><h2 id="JDK中的元注解"><a href="#JDK中的元注解" class="headerlink" title="JDK中的元注解"></a>JDK中的元注解</h2><p>自定义注解通常会指明两个元注释：Retention、Target</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><strong>指定所修饰的Annotation的生命周期</strong></p><p>包含一个RetentionPolicy 类型的成员变量, 使用@Rentention 时必须为该 value 成员变量指定值:</p><ul><li>RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。</li><li>RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解，默认值。</li><li>RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM会保留注释。程序可以通过反射获取该注解。</li></ul><p><img src="/images/image-20220423155132405.png" alt="image-20220423155132405"></p><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</p><table><thead><tr><th>取值(ElementType)</th><th></th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于描述构造器</td></tr><tr><td>FIELD</td><td>用于描述域</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于描述局部变量</td></tr><tr><td>METHOD</td><td>用于描述方法</td></tr><tr><td>PACKAGE</td><td>用于描述包</td></tr><tr><td>PARAMETER</td><td>用于描述参数</td></tr><tr><td>TYPE</td><td>用于描述类、接口(包括注解类型)或enum声明</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>@Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 </p><ul><li>定义为Documented的注解必须设置Retention值为RUNTIME。</li></ul><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>@Inherited: 被它修饰的 Annotation 将具有<strong>继承性</strong>。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。</p><ul><li>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以</li></ul><p>继承父类类级别的注解</p><ul><li>实际应用中，使用较少</li></ul><h2 id="JKD8中注解的新特性"><a href="#JKD8中注解的新特性" class="headerlink" title="JKD8中注解的新特性"></a>JKD8中注解的新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><ol><li><p>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p></li><li><p>MyAnnotation的Target和Retention等元注解和MyAnnotations相同</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyAnnotation.java</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MyAnnotations.java</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可重复注解  </span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;12&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;23&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">//创建一个对应当前时间的Date对象</span></span><br><span class="line">    System.out.println(date1.toString()); <span class="comment">//CST是china Standard Time</span></span><br><span class="line">    System.out.println(date1.getTime()); <span class="comment">//获取当前date对象对应的毫秒数</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1650598323255L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p><strong>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMETER,TYPE_USE。</strong></p><ul><li><p>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 </p></li><li><p>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注解概述&quot;&gt;&lt;a href=&quot;#注解概述&quot; class=&quot;headerlink&quot; title=&quot;注解概述&quot;&gt;&lt;/a&gt;注解概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotati</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>枚举类</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/23/enum/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/23/enum/</id>
    <published>2022-04-23T06:08:59.000Z</published>
    <updated>2022-04-23T06:09:40.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举类的实现"><a href="#枚举类的实现" class="headerlink" title="枚举类的实现"></a>枚举类的实现</h2><ul><li><p><strong>JDK1.5之前需要自定义枚举类</strong></p></li><li><p><strong>JDK 1.5 新增的 enum 关键字用于定义枚举类</strong></p></li><li><p><strong>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</strong></p></li><li><p><strong>当需要定义一组常量时，强烈建议使用枚举类</strong></p></li></ul><h2 id="枚举类的属性"><a href="#枚举类的属性" class="headerlink" title="枚举类的属性"></a><strong>枚举类的属性</strong></h2><ul><li><p><strong>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰</strong></p></li><li><p><strong>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</strong></p></li><li><p><strong>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</strong></p></li></ul><h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><ol><li><p><strong>私有化类的构造器，保证不能在类的外部创建其对象</strong></p></li><li><p><strong>在类的内部创建枚举类的实例。声明为：public static final</strong> </p></li><li><p><strong>对象如果有实例变量，应该声明为private final，并在构造器中初始化</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.SPRING;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">  <span class="comment">//声明Season对象的属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">  <span class="comment">//私有化类构造器，给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.SEASONDESC = seasonDesc; </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//提供当前枚举类的多个对象 public static final</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">  <span class="comment">//获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用enum定义枚举类"><a href="#使用enum定义枚举类" class="headerlink" title="使用enum定义枚举类"></a><strong>使用enum定义枚举类</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义的枚举类默认继承于java.lang.Enum类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">  <span class="comment">//多个对象用逗号隔开，而且省略了public static final，末尾对象用分号结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h2><ul><li><p><strong>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</strong></p></li><li><p><strong>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</strong> ！！返回枚举类中对象名是str的对象</p></li><li><p><strong>toString()：返回当前枚举类对象常量的名称</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread.State[] states = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; states.length;i++) &#123;</span><br><span class="line">  System.out.println(states[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程的状态</span></span><br><span class="line">NEW</span><br><span class="line">RUNNABLE</span><br><span class="line">BLOCKED</span><br><span class="line">WAITING</span><br><span class="line">TIMED_WAITING</span><br><span class="line">TERMINATED</span><br></pre></td></tr></table></figure><h2 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a><strong>实现接口的枚举类</strong></h2><ul><li><p>和普通 Java 类一样，枚举类可以实现一个或多个接口</p></li><li><p>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</p></li><li><p>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">  <span class="comment">//多个对象用逗号隔开，而且省略了public static final，末尾对象用分号结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春风又绿江南岸&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;枚举类的实现&quot;&gt;&lt;a href=&quot;#枚举类的实现&quot; class=&quot;headerlink&quot; title=&quot;枚举类的实现&quot;&gt;&lt;/a&gt;枚举类的实现&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;JDK1.5之前需要自定义枚举类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>String类</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/22/String/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/22/String/</id>
    <published>2022-04-22T12:37:53.000Z</published>
    <updated>2022-04-22T12:38:32.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>String：字符串，使用一对””引起来表示。</p><ul><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的</p><pre><code>            实现了Comparable接口：表示String可以比较大小</code></pre></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>String：代表不可变的字符序列。简称：不可变性。</p><p>体现：1. 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><p>​            2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p><p>​            3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域。</p></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></li><li><p><strong>字符串常量池中是不会存储相同内容的字符串的</strong></p></li></ul><h2 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a); </span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure><p><strong>String str1 = “abc”;与String str2 = new String(“abc”);的区别？</strong></p><ul><li>字符串常量存储在字符串常量池，目的是共享</li><li>字符串非常量对象存储在堆中。即使定义的时字面量值相等的字符串，其在堆中的地址也不同。</li></ul><p><strong>String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？</strong></p><p>答：两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p><p><strong>字符串拼接的特性</strong></p><ul><li>常量与常量的拼接结果在常量池，且常量池不会存在相同内容的常量。</li><li>只要其中有一个是变量，结果就在堆中</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下列程序运行的结果：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>); <span class="comment">//good and</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">  System.out.println(s1 == s3); <span class="comment">//true，因为s2前面加了final视为常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><table><thead><tr><th>int length()</th><th>返回字符串的长度：value.length</th></tr></thead><tbody><tr><td><strong>char charAt(int index)</strong></td><td><strong>返回指定索引处的字符return value[index]</strong></td></tr><tr><td><strong>boolean isEmpty()</strong></td><td><strong>判断是否是空字符串</strong></td></tr><tr><td><strong>String toLowerCase()</strong></td><td><strong>将字符串转化为小写</strong></td></tr><tr><td><strong>String toUpperCase()</strong></td><td><strong>将字符串转化为大写</strong></td></tr><tr><td><strong>String trim()</strong></td><td><strong>返回字符串的副本，忽略前导空白和尾部空白</strong></td></tr><tr><td><strong>boolean equals(Object obj)</strong></td><td><strong>比较字符串的内容是否相同</strong></td></tr><tr><td><strong>boolean equalsIgnoreCase(String anotherString)</strong></td><td><strong>忽略大小写地比较两个字符串内容是否相同</strong></td></tr><tr><td><strong>String concat(String str)</strong></td><td><strong>将指定字符串连接到此字符串的结尾。 等价于用“+”</strong></td></tr><tr><td><strong>int compareTo(String anotherString)</strong></td><td><strong>比较两个字符串的大小</strong> “abc”.compareTo(“abe”)返回值为-2</td></tr><tr><td><strong>String substring(int beginIndex)</strong></td><td><strong>返回一个新的字符串，它是从此字符串的beginIndex开始截取到最后</strong></td></tr><tr><td><strong>String substring(int beginIndex, int endIndex)</strong></td><td><strong>左闭右开截取子字符串</strong></td></tr><tr><td><strong>boolean endsWith(String suffix)</strong></td><td><strong>测试此字符串是否以指定的后缀结束</strong></td></tr><tr><td><strong>boolean startsWith(String prefix)</strong></td><td><strong>测试此字符串是否以指定的前缀开始</strong></td></tr><tr><td><strong>boolean startsWith(String prefix, int toffset)</strong></td><td><strong>测试此字符串从指定索引开始的子字符串是否以指定前缀开始</strong></td></tr><tr><td><strong>boolean contains(CharSequence s)</strong></td><td><strong>当且仅当此字符串包含指定的 char 值序列时，返回 true</strong></td></tr><tr><td><strong>int indexOf(String str)</strong></td><td><strong>返回指定子字符串在此字符串中第一次出现处的索引</strong></td></tr><tr><td><strong>int indexOf(String str, int fromIndex)</strong></td><td><strong>返回从指定索引开始出现的子字符串的位置</strong></td></tr><tr><td><strong>int lastIndexOf(String str)</strong></td><td><strong>返回指定子字符串在此字符串中最右边出现处的索引</strong></td></tr><tr><td><strong>int lastIndexOf(String str, int fromIndex)</strong></td><td><strong>子字符串在字符串中最后一次出现处的索引，从指定的索引开始反向搜索</strong></td></tr><tr><td><strong>String replace(char oldChar, char newChar)</strong></td><td><strong>newChar 替换此字符串中出现的所有 oldChar</strong></td></tr><tr><td><strong>String replace(CharSequence target, CharSequence replacement)</strong></td><td><strong>用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</strong></td></tr><tr><td><strong>String replaceAll(String regex, String replacement)</strong></td><td><strong>用给定的repalcemet替换此字符串所有匹配给定正则的子字符串</strong></td></tr><tr><td><strong>String replaceFirst(String regex, String replacement)</strong></td><td><strong>替换掉第一个正则匹配到的子字符串</strong></td></tr><tr><td><strong>boolean matches(String regex)</strong></td><td><strong>是否匹配正则</strong></td></tr><tr><td><strong>String[] split(String regex)</strong></td><td><strong>根据给定正则表达式的匹配拆分此字符串。</strong></td></tr><tr><td><strong>String[] split(String regex, int limit)</strong></td><td><strong>根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line"><span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line"><span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(string); <span class="comment">// hello,world,java,mysql</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line"><span class="comment">//[&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>CharSequence与String的区别是什么？</strong></p><p>CharSequence与String都能用于定义字符串，但CharSequence的值是可读可写序列，而String的值是只读序列。</p><p>CharSequence是实现这个接口的实例 举例： CharSequence str = “dd”; 就是 CharSequence str = new String(“dd”);</p><p>原文链接：<a href="https://blog.csdn.net/xiaohui2015/article/details/47148663">https://blog.csdn.net/xiaohui2015/article/details/47148663</a></p><h2 id="String与基本数据类型转换"><a href="#String与基本数据类型转换" class="headerlink" title="String与基本数据类型转换"></a>String与基本数据类型转换</h2><p><strong>字符串</strong>➡️<strong>基本数据类型、包装类</strong></p><ul><li>Integer包装类的public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型。</li><li>类似地,使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;123.45&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">num3</span> <span class="operator">=</span> Double.parseDouble(s3);</span><br><span class="line">System.out.println(num3); <span class="comment">//123.45</span></span><br></pre></td></tr></table></figure><p><strong>基本数据类型、包装类</strong>➡️<strong>字符串</strong></p><ul><li>调用String类的public String valueOf(int n)可将int型转换为字符串</li><li>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> String.valueOf(num3);</span><br><span class="line">System.out.println(s4); <span class="comment">//&quot;123.45&quot;</span></span><br></pre></td></tr></table></figure><h2 id="String与字符数组转换"><a href="#String与字符数组转换" class="headerlink" title="String与字符数组转换"></a>String与字符数组转换</h2><p><strong>字符数组➡️字符串</strong></p><ul><li>String 类的构造器：String(char[]) <strong>和</strong> String(char[]<strong>，</strong>int offset<strong>，</strong>int length) 分别用字符数组中的全部字符和部分字符创建字符串对象。</li></ul><p><strong>字符串➡️字符数组</strong></p><ul><li>public char[] toCharArray()<strong>：</strong>将字符串中的全部字符存放在一个字符数组中的方法。</li><li>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)<strong>：</strong>提供了将指定索引范围内的字符串存放到数组中的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray(); <span class="comment">//&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;&#125;</span></span><br><span class="line"><span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr); <span class="comment">//&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="String与字节数组转换"><a href="#String与字节数组转换" class="headerlink" title="String与字节数组转换"></a>String与字节数组转换</h2><p><strong>字节数组➡️字符串</strong></p><ul><li>String(byte[])<strong>：</strong>通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li><li>String(byte[]<strong>，</strong>int offset<strong>，</strong>int length) <strong>：</strong>用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</li></ul><p><strong>字符串➡️字节数组</strong></p><ul><li>public byte[] getBytes() <strong>：</strong>使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</li><li>public byte[] getBytes(String charsetName) <strong>：</strong>使用指定的字符集将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">//默认为utf-8,可以传参数，比如gbk</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));<span class="comment">//[97,98,99]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">//使用默认字符集进行解码</span></span><br><span class="line">System.out.println(str2);<span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对比String、StringBuffer、StringBuilder"><a href="#对比String、StringBuffer、StringBuilder" class="headerlink" title="对比String、StringBuffer、StringBuilder"></a>对比String、StringBuffer、StringBuilder</h2><ul><li>String：不可变字符序列</li><li>StringBuffer：可变字符序列、效率低、线程安全</li><li>StringBuilder：可变字符序列、效率高、线程不安全。jdk5.0新增的</li><li>作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</li><li>在开发中考虑是否时多线程问题，底层都是用char[]数组存储。</li></ul><h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p>StringBuffer<strong>类不同于</strong>String<strong>，其对象必须使用构造器生成。有三个构造器：</strong></p><ul><li>StringBuffer()：初始容量为16的字符串缓冲区</li><li>StringBuffer(int size)：构造指定容量的字符串缓冲区</li><li>StringBuffer(String str)：将内容初始化为指定字符串内容</li></ul><p>扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。</p><p>指导意义：开发中建议大家使用：StringBuffer(int capacity)或StringBuilder(int capacity)</p><h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><table><thead><tr><th>append(xxx)</th><th>用于字符串拼接</th></tr></thead><tbody><tr><td><strong>delete(int start,int end)</strong></td><td><strong>删除指定内容</strong></td></tr><tr><td><strong>replace(int start,int end,String str)</strong></td><td><strong>把[start,end)位置替换为str</strong></td></tr><tr><td><strong>insert(int offset,xxx)</strong></td><td><strong>在指定位置插入xxx</strong></td></tr><tr><td><strong>reverse()</strong></td><td><strong>把当前字符序列逆转</strong></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还定义了如下方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> n )</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n ,<span class="type">char</span> ch)</span></span><br></pre></td></tr></table></figure><p><strong>StringBuilder 和 StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;String类&quot;&gt;&lt;a href=&quot;#String类&quot; class=&quot;headerlink&quot; title=&quot;String类&quot;&gt;&lt;/a&gt;String类&lt;/h2&gt;&lt;p&gt;String：字符串，使用一对””引起来表示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String声明为f</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java比较器</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/22/javaCompare/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/22/javaCompare/</id>
    <published>2022-04-22T12:22:09.000Z</published>
    <updated>2022-04-22T12:25:32.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自然排序-java-lang-Comparable"><a href="#自然排序-java-lang-Comparable" class="headerlink" title="自然排序 java.lang.Comparable"></a>自然排序 <strong>java.lang.Comparable</strong></h2><p><strong>CompareTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java中的对象，正常情况下只能进行比较==或！=。不能使用&gt;或&lt;的。</span></span><br><span class="line"><span class="comment"> * 但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</span></span><br><span class="line"><span class="comment"> * 如何实现？</span></span><br><span class="line"><span class="comment"> * 使用comparable或者comparator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string、包装类等实现了comparable接口，重写了compareTo()方法，给出了比较两个对象大小的方式。</span></span><br><span class="line"><span class="comment">     * string、包装类重写compareTo()方法后，进行了从小到大排列。</span></span><br><span class="line"><span class="comment">     * 重写compareTo(obj)规则：</span></span><br><span class="line"><span class="comment">     * 1.如果当前对象this大于形参对象obj，则返回正整数。</span></span><br><span class="line"><span class="comment">     * 2.如果当前对象this小于形参对象obj，则返回负整数。</span></span><br><span class="line"><span class="comment">     * 3.如果当前对象this等于形参对象obj，则返回0。</span></span><br><span class="line"><span class="comment">     * 对于自定义类来说，如果需要排序的话，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</span></span><br><span class="line"><span class="comment">     * 在compareTo(obj)方法中指明如何排序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;a&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;b&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;c&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;d&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;e&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Goods.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器、get、set、toString方法省略</span></span><br><span class="line">    <span class="comment">//指明商品比较大小方式,按价格从低到高排序,名称升序</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">//重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//这里返回1是，this.price比goods.price大，返回1就可以理解为放在后面的意思</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//return 0;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">                <span class="comment">//return -this.name.compareTo(goods.name); //从高到低</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//            return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="定制排序-java-util-Comparator"><a href="#定制排序-java-util-Comparator" class="headerlink" title="定制排序 java.util.Comparator"></a>定制排序 <strong>java.util.Comparator</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那</span></span><br><span class="line"><span class="comment">     * 么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排序的比较。</span></span><br><span class="line"><span class="comment">     * 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示</span></span><br><span class="line"><span class="comment">     * o1小于o2。</span></span><br><span class="line"><span class="comment">     * 3.可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</span></span><br><span class="line"><span class="comment">     * 4.还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        Goods[] arr1 = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr1[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;a&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr1[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;a&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr1[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;c&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr1[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;d&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr1[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;e&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        Arrays.sort(arr1, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Goods&gt;() &#123;</span><br><span class="line">            <span class="comment">//指定产品名称从低到高，再按价格从高到低</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Goods o1, Goods o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (o1.getName().equals(o2.getName())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -Double.compare(o1.getPrice(),o2.getPrice());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        <span class="comment">//[Goods&#123;name=&#x27;a&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;a&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;c&#x27;, price=12.0&#125;, Goods&#123;name=&#x27;d&#x27;, price=65.0&#125;, Goods&#123;name=&#x27;e&#x27;, price=43.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Comparable接口与Comparator的使用对比"><a href="#Comparable接口与Comparator的使用对比" class="headerlink" title="Comparable接口与Comparator的使用对比"></a>Comparable接口与Comparator的使用对比</h2><ul><li><p><strong>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小</strong></p></li><li><p><strong>Comparator接口属于临时性的比较。</strong></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自然排序-java-lang-Comparable&quot;&gt;&lt;a href=&quot;#自然排序-java-lang-Comparable&quot; class=&quot;headerlink&quot; title=&quot;自然排序 java.lang.Comparable&quot;&gt;&lt;/a&gt;自然排序 &lt;stron</summary>
      
    
    
    
    
    <category term="java" scheme="https://lzjzzzzzzz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/18/Mysql1/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/18/Mysql1/</id>
    <published>2022-04-18T06:06:35.000Z</published>
    <updated>2022-04-23T15:24:05.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p><img src="/images/image-20220305154604127.png" alt="image-20220305154604127"></p><p><img src="/images/image-20220305154703681.png" alt="image-20220305154703681"></p><h3 id="DDL-数据库操作"><a href="#DDL-数据库操作" class="headerlink" title="DDL-数据库操作"></a>DDL-数据库操作</h3><p><img src="/images/image-20220305154955897.png" alt="image-20220305154955897"></p><p><img src="/images/image-20220305155727834.png" alt="image-20220305155727834"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database it <span class="keyword">default</span> charset utf8m64 <span class="operator">/</span><span class="operator">/</span>指定字符集</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220305160003976.png" alt="image-20220305160003976"></p><p>切换到itcast //查看当前数据库</p><p><img src="/images/image-20220305160306038.png" alt="image-20220305160306038"></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><img src="/images/image-20220305170217431.png" alt="image-20220305170217431"></p><p><img src="/images/image-20220305170256512.png" alt="image-20220305170256512"> </p><p><img src="/images/image-20220305170632472.png" alt="image-20220305170632472"></p><p><img src="/images/image-20220305171141059.png" alt="image-20220305171141059"></p><p><img src="/images/image-20220305171316617.png" alt="image-20220305171316617"></p><p><img src="/images/image-20220305171443259.png" alt="image-20220305171443259"></p><p><img src="/images/image-20220305171512487.png" alt="image-20220305171512487"></p><p><img src="/images/image-20220305171557351.png" alt="image-20220305171557351"></p><p><img src="/images/image-20220305171608798.png" alt="image-20220305171608798"></p><p><img src="/images/image-20220305171745754.png" alt="image-20220305171745754"></p><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p><img src="/images/image-20220305213759930.png" alt="image-20220305213759930"></p><p><img src="/images/image-20220306155706393.png" alt="image-20220306155706393"></p><p><img src="/images/image-20220306155746215.png" alt="image-20220306155746215"></p><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><p><img src="/images/image-20220306160023343.png" alt="image-20220306160023343"></p><p><img src="/images/image-20220306160103900.png" alt="image-20220306160103900"></p><p><img src="/images/image-20220306160314627.png" alt="image-20220306160314627"></p><p> <img src="/images/image-20220306160714696.png" alt="image-20220306160714696"></p><p>null值不不参与所有聚合函数运算</p><p><img src="/images/image-20220306175054385.png" alt="image-20220306175054385"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询年龄小于<span class="number">45</span>的员工，并根据工作地址分组，获取员工数量大于等于<span class="number">3</span>的工作地址</span><br><span class="line"><span class="keyword">select</span> workaddress,<span class="built_in">count</span>(<span class="operator">*</span>) address_count <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span><span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#根据年龄对公司的员工进行生序排序，年龄相同，再按照入职时间进行降序排序</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> , entrydate <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220306191159996.png" alt="image-20220306191159996"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询第二页数据，每页展示<span class="number">10</span>条记录 <span class="comment">-------&gt;（页码-1）*页展示记录数</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp limit <span class="number">10</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220306191716166.png" alt="image-20220306191716166"></p><p><img src="/images/image-20220306191932848.png" alt="image-20220306191932848"></p><h3 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h3><p><img src="/images/image-20220306192151671.png" alt="image-20220306192151671"></p><p>可以在关键词后面编写字段别名验证执行顺序</p><h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><p><img src="/images/image-20220306194157844.png" alt="image-20220306194157844"></p><p><img src="/images/image-20220306194109110.png" alt="image-20220306194109110"></p><p><img src="/images/image-20220306194501896.png" alt="image-20220306194501896"></p><p><img src="/images/image-20220306195325544.png" alt="image-20220306195325544"></p><p><img src="/images/image-20220306195343435.png" alt="image-20220306195343435"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p> <img src="/images/image-20220306200025732.png" alt="image-20220306200025732"></p><p>select 函数(参数)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">substring</span>(<span class="string">&#x27;Hello World&#x27;</span>,<span class="number">1</span>,<span class="number">5</span>); #Hello</span><br><span class="line">#将企业员工工号不足<span class="number">5</span>位数的全部在前面补<span class="number">0</span>，比如：<span class="number">1</span>号员工的工号应该为<span class="number">00001</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> workno <span class="operator">=</span> lpad(workno,<span class="number">5</span>,<span class="string">&#x27;0&#x27;</span>); # <span class="number">1</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">00001</span></span><br></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p><img src="/images/image-20220306201101682.png" alt="image-20220306201101682"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#通过数据库的函数，生成一个六位数的随机验证码</span><br><span class="line"><span class="keyword">select</span> lpad(round(rand()<span class="operator">*</span><span class="number">1000000</span>,<span class="number">0</span>),<span class="number">6</span>,<span class="string">&#x27;0&#x27;</span>); #<span class="number">0</span><span class="number">-1</span>之间的随机小数乘<span class="number">1000000</span>，再四舍五入保留<span class="number">0</span>位小数，不足<span class="number">6</span>位补<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p><img src="/images/image-20220307110331776.png" alt="image-20220307110331776"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#往后推<span class="number">70</span>年</span><br><span class="line"><span class="keyword">select</span> date_add(now(),<span class="type">INTERVAL</span> <span class="number">70</span> <span class="keyword">YEAR</span>);</span><br><span class="line">#datediff 第一个时间减去第二个时间</span><br><span class="line"><span class="keyword">select</span> datediff(<span class="string">&#x27;2021-12-01&#x27;</span>,<span class="string">&#x27;2021-11-01&#x27;</span>);</span><br><span class="line">#查询所有员工的入职天数，并根据入职天数倒序排序</span><br><span class="line"><span class="keyword">select</span> name,datediff(curdate(),entrydate) <span class="keyword">as</span> <span class="string">&#x27;entrydays&#x27;</span> <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> entrydays <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307111248187.png" alt="image-20220307111248187"></p><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p> <img src="/images/image-20220307135051502.png" alt="image-20220307135051502"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ifnull(<span class="keyword">null</span>,<span class="string">&#x27;default&#x27;</span>); # <span class="keyword">default</span></span><br><span class="line">#<span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">then</span> <span class="keyword">else</span> <span class="keyword">end</span></span><br><span class="line">#需求：查询emp表的员工姓名和工作地址（北京、上海<span class="comment">--&gt;一线城市，其他--&gt;二线城市）</span></span><br><span class="line"><span class="keyword">select</span> name, (<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span>       <span class="keyword">from</span> emp;</span><br><span class="line">#案例：统计班级各个学员的成绩，展示的规则如下：<span class="operator">&gt;=</span><span class="number">85</span>,展示优秀 <span class="operator">&gt;=</span><span class="number">60</span>,展示及格 否则展示不及格</span><br><span class="line"><span class="keyword">select</span> id,name,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;数学&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> english <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;英语&#x27;</span>,</span><br><span class="line">(<span class="keyword">case</span> <span class="keyword">when</span> chinese <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span> <span class="string">&#x27;优秀&#x27;</span> <span class="keyword">when</span> math <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span> <span class="string">&#x27;及格&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;不及格&#x27;</span> <span class="keyword">end</span>) <span class="string">&#x27;语文&#x27;</span></span><br><span class="line"><span class="keyword">from</span> score;</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/image-20220307141410326.png" alt="image-20220307141410326"></p><p>注意：约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="/images/image-20220307143033603.png" alt="image-20220307143033603"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span> comment <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">check</span> ( age <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">&amp;&amp;</span> age <span class="operator">&lt;=</span> <span class="number">120</span> ) comment <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">    status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span> comment <span class="string">&#x27;状态&#x27;</span>,</span><br><span class="line">    gender <span class="type">char</span>(<span class="number">1</span>) comment <span class="string">&#x27;性别&#x27;</span></span><br><span class="line">)comment <span class="string">&#x27;用户表&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="外建约束"><a href="#外建约束" class="headerlink" title="外建约束"></a>外建约束</h3><p><img src="/images/image-20220307145628303.png" alt="image-20220307145628303"></p><p><img src="/images/image-20220307151035004.png" alt="image-20220307151035004"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#添加外建  给emp表的部门dept_id添加外建关联dept表的id</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line">#给子表添加外建之后，我们不能更新或者删除父表的记录，因为存在外键的关联</span><br><span class="line">#删除外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> <span class="keyword">foreign</span> key fk_emp_dept_id;</span><br><span class="line">#外键的删除和更新行为 级联</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307151312372.png" alt="image-20220307151312372"></p><p><img src="/images/image-20220307151634171.png" alt="image-20220307151634171"></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><p><img src="/images/image-20220307152653485.png" alt="image-20220307152653485"></p><p><img src="/images/image-20220307152759271.png" alt="image-20220307152759271"></p><p><img src="/images/image-20220307152849934.png" alt="image-20220307152849934"></p><p><img src="/images/image-20220307153228042.png" alt="image-20220307153228042"></p><h3 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h3><p><img src="/images/image-20220307155850722.png" alt="image-20220307155850722"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#多表查询</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307160246157.png" alt="image-20220307160246157"></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p><img src="/images/image-20220307160428361.png" alt="image-20220307160428361"></p><p><img src="/images/image-20220307160843190.png" alt="image-20220307160843190"></p><p><img src="/images/image-20220307160910221.png" alt="image-20220307160910221"></p><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p><img src="/images/image-20220307161114398.png" alt="image-20220307161114398"></p><p>左外连接会完全包含左表的数据，即使是null</p><p><img src="/images/image-20220307161510886.png" alt="image-20220307161510886"></p><p>  右外连接</p><p><img src="/images/image-20220307161726442.png" alt="image-20220307161726442"></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p><img src="/images/image-20220307162259920.png" alt="image-20220307162259920"></p><p><img src="/images/image-20220307162148436.png" alt="image-20220307162148436"></p><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p><img src="/images/image-20220307162608284.png" alt="image-20220307162608284"></p><p><img src="/images/image-20220307162522640.png" alt="image-20220307162522640"></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><img src="/images/image-20220307204819480.png" alt="image-20220307204819480"></p><p><img src="/images/image-20220307210031925.png" alt="image-20220307210031925"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#标量子查询</span><br><span class="line">#查询“销售部”的所有员工信息 </span><br><span class="line">#a.查询“销售”部门id </span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line">#b.根据销售部部门id，查询员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line">#查询“房东白”入职之后的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;房东白&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307210100098.png" alt="image-20220307210100098"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#列子查询</span><br><span class="line">#<span class="number">1.</span>查询“销售部”和“市场部”的所有员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="keyword">in</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line">#<span class="number">2.</span>查询比财务部所有人工资都高的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line">#<span class="number">3.</span>查询比研发部其中任意一人工资高的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220307214447568.png" alt="image-20220307214447568"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1.</span>查询与张无忌的薪资及直属领导相同的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> (salary,managerid) <span class="operator">=</span> (<span class="keyword">select</span> salary,managerid <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张无忌&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220308100305770.png" alt="image-20220308100305770"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查询与“鹿杖客”、“宋远桥”的职位和薪资相同的员工信息</span><br><span class="line">a查询返回的是表，<span class="keyword">in</span> 在返回的表中信息多选一，要么满足上面的要么满足下面的 </span><br><span class="line"></span><br><span class="line">#查询入职日期是“<span class="number">2006</span><span class="number">-01</span><span class="number">-01</span>”之后的员工信息，及其部门信息</span><br><span class="line">#a.入职日期是“<span class="number">2006</span><span class="number">-01</span><span class="number">-01</span>”之后的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>;</span><br><span class="line">#b.查询这部分员工，对应的部门信息</span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220308100527437.png" alt="image-20220308100527437"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220308125803696.png" alt="image-20220308125803696"></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h3><p>如果在事务的执行过程中出现了异常，那我们得回滚事务，从而来保证数据的完整性和一致性。</p><p>MySQL事务是默认自动提交的</p><p><img src="/images/image-20220308130557717.png" alt="image-20220308130557717"></p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p><img src="/images/image-20220308132526189.png" alt="image-20220308132526189"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="variable">@autocommit</span> 为<span class="number">1</span>说明事物自动提交 为<span class="number">0</span>说明手动提交</span><br><span class="line">#转账操作 </span><br><span class="line">#<span class="number">1.</span>查询张三账户余额</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">2.</span>将张三账户余额<span class="number">-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">3.</span>将李四账户余额<span class="operator">+</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="/images/image-20220308133315314.png" alt="image-20220308133315314"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#转账操作 </span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line">#<span class="number">1.</span>查询张三账户余额</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">2.</span>将张三账户余额<span class="number">-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">#<span class="number">3.</span>将李四账户余额<span class="operator">+</span><span class="number">1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line">#提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line">#回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h3 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h3><p><img src="/images/image-20220308134331227.png" alt="image-20220308134331227"></p><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p> <img src="/images/image-20220308150547235.png" alt="image-20220308150547235"></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="/images/image-20220308150826913.png" alt="image-20220308150826913"></p><p>从上到下性能变差，事务安全性变高。所以要权衡数据库的安全性和并发性。</p><p><img src="/images/image-20220308150938771.png" alt="image-20220308150938771"></p><p>脏读：原始数据0 B事务+1000，还没commit A事务查询：1000</p><p>不可重复读：原始数据：0,B事务+1000,A事务查询第一次：0 Bcommit之后 A事务查询：1000  </p><p>幻读：A事务查询id为3的数据为空—&gt;B事务插入id为3的数据并且commit—&gt;A事务插入id为3的数据失败，显示重复的id已经存在—&gt;A事务查询id为3的数据为空（出现“幻觉  ”）-&gt;commit A ，数据表中出现B提交的数据</p><p>Serializable：A事务查询id为4的数据为空—&gt;B事务插入id为4的数据（阻塞—&gt;A事务插入id为4的数据—&gt;commitA—&gt;B事务Error：id为4的事务已经提交</p><p><strong>串行化指的是：在进行并发操作的时候只允许一次一个事务来操作</strong> </p><p><strong>事务隔离级别越高，数据越安全，但是性能越低</strong></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="/images/image-20220308160342653.png" alt="image-20220308160342653"></p><p><img src="/images/image-20220308160404844.png" alt="image-20220308160404844"></p><h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><p>不同的存储引擎在存储数据、建议索引、更新\查询等技术的实现方式不一样。  </p><p>存储引擎就是存储数据、建议索引、更新\查询等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称之为表类型。</p><p>默认存储引擎：InnoDB</p><p><img src="/images/image-20220308192507590.png" alt="image-20220308192507590"></p><p><img src="/images/image-20220308212849926.png" alt="image-20220308212849926"></p><h3 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h3><p><img src="/images/image-20220308212639638.png" alt="image-20220308212639638"></p><p><img src="/images/image-20220308213453139.png" alt="image-20220308213453139"></p><p><img src="/images/image-20220308220554874.png" alt="image-20220308220554874"></p><p><img src="/images/image-20220308220706033.png" alt="image-20220308220706033"></p><p><img src="/images/image-20220308220858786.png" alt="image-20220308220858786"></p><p><strong>InnoDB与MyISAM三大区别：InnoDB是支持事务的，而MyISAM不支持。InnoDB支持行锁，而MyISAM支持表锁；InnoDB支持外键，而MyISAM不支持。</strong></p><h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><p>存储引擎没有好坏之分，我们只要在合适的场景选用合适的存储引擎即可。</p><p><img src="/images/image-20220308221600496.png" alt="image-20220308221600496"></p><p><strong>现在基本上MyISAM被MongoDB所替代，而在使用MEMORY的场景被Redis所替代</strong> </p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><img src="/images/image-20220310172649093.png" alt="image-20220310172649093"></p><p> <img src="/images/image-20220310173008544.png" alt="image-20220310173008544"></p><p> <img src="/images/image-20220310173152469.png" alt="image-20220310173152469"></p><p>劣势基本可以忽略：1.磁盘现在是很便宜的 2.对于一个正常的业务系统来说，增删改的比例很小，主要是查询</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><img src="/images/image-20220310173645519.png" alt="image-20220310173645519"></p><p><img src="/images/image-20220310173726059.png" alt="image-20220310173726059"></p><p>我们平时所说的索引，如果没有特别指明，都是指B+树结构组织的索引。</p><p><img src="/images/image-20220310174324552.png" alt="image-20220310174324552"></p><p><img src="/images/image-20220310223433288.png" alt="image-20220310223433288"></p><p><img src="/images/image-20220310175142111.png" alt="image-20220310175142111"></p><p><img src="/images/image-20220310175810503.png" alt="image-20220310175810503"></p><p><strong>所有的元素都会出现在叶子结点，在B+树的数据结构中，叶子结点形成了一个单向链表</strong></p><p> <img src="/images/image-20220310222314054.png" alt="image-20220310222314054"></p><p><img src="/images/image-20220310222416929.png" alt="image-20220310222416929"></p><p><img src="/images/image-20220310222813547.png" alt="image-20220310222813547"></p><p><img src="/images/image-20220310223107506.png" alt="image-20220310223107506"></p><p>​    <img src="/images/image-20220311143610346.png" alt="image-20220311143610346"></p><p><strong>在B+树的结构中叶子结点形成了双向链表，便于范围搜素和采集，不管查找哪一个数据都要到叶子结点中去搜索，搜索效率稳定</strong></p><p><strong>为什么不用Hash索引？Hash索引只支持等值匹配，不支持范围匹配及排序操作</strong> </p><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="/images/image-20220311143811615.png" alt="image-20220311143811615"></p><p>  <img src="/images/image-20220311144154244.png" alt=" "></p><p>​    <img src="/images/image-20220311144419306.png" alt="image-20220311144419306"></p><p><strong>聚集索引下面的row表示一整行的数据</strong></p><p><strong>二级索引下面叶子结点挂的是对应的id</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当我们执行</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span> 时</span><br><span class="line">先走二级索引拿到Arm对应的<span class="number">10</span>，然后再到聚集索引中进行对比</span><br><span class="line">回表查询：指的是先走二级索引找到对应的主键值，再根据主键值到聚集索引中拿到这一行的行数据</span><br></pre></td></tr></table></figure><p> == <strong>回表查询：指的是先走二级索引找到对应的主键值，再根据主键值到聚集索引中拿到这一行的行数据</strong> == </p><p><img src="/images/image-20220311150103265.png" alt="image-20220311150103265"></p><p>1</p><p><img src="/images/image-20220311152913379.png" alt="image-20220311152913379"></p><h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><p><img src="/images/image-20220311153153960.png" alt="image-20220311153153960"></p><p><img src="/images/image-20220311154823492.png" alt="image-20220311154823492"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查询表的索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br><span class="line">#<span class="keyword">show</span> index <span class="keyword">from</span> tb_user\G; 以列的形式展示</span><br><span class="line">#创建索引  默认B<span class="operator">+</span> tree 索引</span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name); </span><br><span class="line">#创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br><span class="line">#创建联合索引 ?</span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br><span class="line">#email</span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br></pre></td></tr></table></figure><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><p>要SQL优化，主要优化查询语句</p><p><img src="/images/image-20220311160304177.png" alt="image-20220311160304177"></p><p><img src="/images/image-20220311160350991.png" alt="image-20220311160350991"></p><p><strong>上表查询为主</strong></p><p><img src="/images/image-20220311160642936.png" alt="image-20220311160642936"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220311160839076.png" alt="image-20220311160839076"></p><p> 慢查询日志</p><p><img src="/images/image-20220311161440182.png" alt="image-20220311161440182"></p><p><img src="/images/image-20220311161259562.png" alt="image-20220311161259562"></p><p><img src="/images/image-20220311161805944.png" alt="image-20220311161805944"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#查看profiling是否开启了对应的开关</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220311162051192.png" alt="image-20220311162051192"></p><p><img src="/images/image-20220311162425720.png" alt="image-20220311162425720"></p><p><strong>explain执行计划</strong></p><p><img src="/images/image-20220311205042667.png" alt="image-20220311205042667"></p><p> <img src="/images/image-20220311221310056.png" alt="image-20220311221310056"></p><p><img src="/images/image-20220313190200415.png" alt="image-20220313190200415"></p><p><img src="/images/image-20220313185722666.png" alt="image-20220313185722666"></p><img src="/images/image-20220313185945811.png" alt="image-20220313185945811" style="zoom:50%;" /><p>type值为null性能最好，一般通过主键访问会出现const ，对非唯一的索引会出现ref，在优化sql语句的时候尽量把type往前优化。如果出现all代表选表扫描性能会比较低，如果出现index说明用了索引，但是也会对索引进行扫描遍历 </p><p><img src="/images/image-20220313191006132.png" alt="image-20220313191006132"></p><p><img src="/images/image-20220313190455949.png" alt="image-20220313190455949"></p><p><img src="/images/image-20220313191129592.png" alt="image-20220313191129592"></p><p><img src="/images/image-20220313191227263.png" alt="image-20220313191227263"></p><h3 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h3><p><img src="/images/image-20220313192032932.png" alt="image-20220313192032932"></p><p>在没有对sn字段创建索引之前，由于是千万级的数据，查询操作话费了20s左右，创建索引花了1分11秒左右之后，再次执行相同的对sn的查询操作，执行时间0.00s</p><p><img src="/images/image-20220313192305970.png" alt="image-20220313192305970"></p><p><img src="/images/image-20220313192958219.png" alt="image-20220313192958219"></p><p>前三条语句满足最左前缀法则，第四、 五条语句不满足最左前缀法则 </p><p><img src="/images/image-20220313193212882.png" alt="image-20220313193212882"></p><p>根据key_len对比发现，profession走了索引，status没有走索引。部分失效了 </p><p><img src="/images/image-20220313193444949.png" alt="image-20220313193444949"></p><p>这种情况下，索引都生效了，为什么呢？最左前缀法则指的是索引中的最左边的字段必须存在 ，跟放的位置是没有关系的</p><p><img src="/images/image-20220313194125621.png" alt="image-20220313194125621"></p><p><img src="/images/image-20220313193830361.png" alt="image-20220313193830361"></p><p>对比key_len可以发现，status是没有走索引的，是因为age使用了范围查询，范围查询右边的列索引将会失效 </p><p><img src="/images/image-20220313194023718.png" alt="image-20220313194023718"></p><p>对比key_len可以发现，联合索引都用上了，如果业务允许的情况下，尽量使用≥这样的 </p><p><strong>索引失效情况</strong></p><p><img src="/images/image-20220313194514251.png" alt="image-20220313194514251"></p><p><img src="/images/image-20220313194423165.png" alt="image-20220313194423165"></p><p><img src="/images/image-20220313194723975.png" alt="image-20220313194723975"></p><p><img src="/images/image-20220313194636086.png" alt="image-20220313194636086"></p><p><img src="/images/image-20220313194901332.png" alt="image-20220313194901332"></p><p><img src="/images/image-20220313194832319.png" alt="image-20220313194832319"></p><p><img src="/images/image-20220313195258996.png" alt="image-20220313195258996"></p><p><img src="/images/image-20220313195237699.png" alt="image-20220313195237699"></p><p><img src="/images/image-20220313195833227.png" alt="image-20220313195833227"></p><p>一般情况下，如果大多数数据满足情况，那么走全表（适用以上的语句</p><p><img src="/images/image-20220313195647822.png" alt="image-20220313195647822"></p><p><img src="/images/image-20220313200056429.png" alt="image-20220313200056429"></p><p>下面不走索引，因为绝大多数为notnull，</p><p>取决于当前这个数据库表结构的数据分布情况 </p><p><strong>SQL提示</strong></p><p><img src="/images/image-20220313200832243.png" alt="image-20220313200832243"></p><p><img src="/images/image-20220313201117026.png" alt="image-20220313201117026"></p><p><img src="/images/image-20220313201152541.png" alt="image-20220313201152541"></p><p><img src="/images/image-20220313201915536.png" alt="image-20220313201915536"></p><p><strong>using where using index 性能高，using index condition性能低</strong></p><p>上面的查询1使用到的索引是二级索引，而这个二级索引中，有id、profession、age、status，查询1不需要回表</p><p>而查询2有字段name，需要回表到聚集索引中查询</p><p><img src="/images/image-20220313202043002.png" alt="image-20220313202043002"></p><p><img src="/images/image-20220313202957726.png" alt="image-20220313202957726"></p><p><img src="/images/image-20220313203050352.png" alt="image-20220313203050352"></p><p>gender超出了覆盖索引的字段，所以我们先要扫描辅助索引，再去扫描聚集索引。</p><p>使用select * 很容易出现回表查询，除非创建了一个联合索引，这个联合索引包含了这张表的所有字段。</p><p><img src="/images/image-20220316172330887.png" alt="image-20220316172330887"></p><p><strong>对与username和password建立联合索引，由于二级索引下面挂的是id，所以不需要回表查询，直接覆盖索引</strong></p><p><strong>MySQL 前缀索引能有效减小索引文件的大小，提高索引的速度。但是前缀索引也有它的坏处：MySQL 不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引(Covering Index)</strong></p><p><img src="/images/image-20220316172947625.png" alt="image-20220316172947625"></p><p>​             <img src="/images/image-20220316173227121.png" alt="image-20220316173227121"></p><p><img src="/images/image-20220316173246644.png" alt="image-20220316173246644"></p><p>如果说选择性尽可能高，那就取10个前缀。如果要去平衡选择性和索引的前缀（索引的体积），那么可以选择5个前缀</p><p><img src="/images/image-20220316173535141.png" alt="image-20220316173535141"></p><p>取5个前缀的email的sub_part为5</p><p><img src="/images/image-20220316173702610.png" alt="image-20220316173702610"></p><p>因为前5个字符区分度已经比较高了，所以我们用5个字符来构建辅助索引</p><p>下面总结一下什么情况下使用前缀索引：</p><ul><li><p>字符串列(varchar,char,text等)，需要进行全字段匹配或者前匹配。也就是=‘xxx’ 或者 like ‘xxx%’</p></li><li><p>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</p></li><li><p>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</p><p><img src="/images/image-20220316193244089.png" alt="image-20220316193244089"></p><p><img src="/images/image-20220316193139491.png" alt="image-20220316193139491"></p></li></ul><p>上面看Extra字段，上面是NULL需要回表查询，下面不需要</p><p>**在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引 **</p><p><img src="/images/image-20220316193436707.png" alt="image-20220316193436707"></p><p><img src="/images/image-20220316193544012.png" alt="image-20220316193544012"></p><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p><img src="/images/image-20220316194452428.png" alt="image-20220316194452428"></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220316194842323.png" alt="image-20220316194842323"></p><p><strong>执行频次：判定当前数据库是插入为主还是更新为主还是删除为主还是查询为主，我们主要针对查询频次比较高的数据库进行优化</strong></p><p><strong>慢查询日志：可以辨认出哪些sql语句执行比较耗时，只会记录执行时间超过了预设时间的sql</strong></p><p><strong>Profile：监控每一条语句的耗时，以及具体的时间耗费在哪一个阶段</strong></p><p><strong>explain：通过explain查看sql语句的执行计划，来评判sql语句的性能</strong></p><p>**联合索引：最左前缀法则，最左边的列必须存在，如果最左边的列不存在，整个联合索引都失效了 **</p><p><strong>索引失效：不要在索引列上进行函数运算，否则索引失效；字符串不加引号，会造成隐式类型转换，会造成索引失效；like模糊匹配，%加在前面；or连接的条件，如果一个有索引，一个没有索引；如果mysql评估走全表扫描比走索引还快，那么索引也会失效（数据分布的影响）；</strong></p><p><strong>SQL提示：我们在执行select语句的时候，如果有很多的索引，那么MySQL会根据它内部的策略来选择使用哪个索引，我们也可以给MySQL一些提示，告诉它你要用哪个索引，忽略哪个索引，强制使用哪个索引。</strong></p><p><strong>覆盖索引：查询返回的列在索引结构中都包含了，不需要回表查询了</strong></p><p><strong>回表查询：我们在查询的时候先走二级索引，先检索到这一行数据的id，再根据id再到聚集索引中再查找这一行的数据</strong></p><p><strong>前缀索引：当遇到字符串前缀较长，或者是大文本的时候，我们可以针对它建立前缀索引来缩小索引的体积，提高检索效率</strong></p><p><strong>单列/联合索引：推荐使用联合索引，因为联合索引性能较高；如果联合索引使用得当，可以避免回表查询</strong></p><p><strong>索引设计原则：1.我需要针对于哪些表来设计索引？（数据量大，而且查询频率较高）2.我需要针对于这些表的哪些字段建立索引（经常在where、orderby、groupby之后出现的字段来建立对应的索引）</strong></p><p><img src="/images/image-20220321114110586.png" alt="image-20220321114110586"></p><p><strong>如果这一列是唯一的，那尽量建立唯一索引；如果能建立联合索引，尽量使用联合索引；如果涉及到一些字符串长度较长，或者是大本文字段，我们尽量使用前缀索引。</strong></p><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p><img src="/images/image-20220321133542103.png" alt="image-20220321133542103"></p><p>批量插入时建议一次不要插入超过1000条数据，可以分批批量插入 </p><p><strong>主键顺序插入的性能要高于乱序插入</strong></p><p> <strong>–local infile 表示需要去加载本地的文件</strong></p><p><img src="/images/image-20220321133836953.png" alt="image-20220321133836953"></p><p><strong>每个元素之间使用”,”分隔，每一行之间使用”\n”分隔</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@local</span>_infile #查看开关是否开启，默认是关闭的</span><br><span class="line">#开启</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure><p><img src="/images/image-20220321134609563.png" alt="image-20220321134609563"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l load_user_100w_sort.sql #查看有多少行</span><br><span class="line">head load_user_100w_sort.sql #查看前面几行数据详情</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p><img src="/images/image-20220321135258031.png" alt="image-20220321135258031"></p><p> <img src="/images/image-20220321135828933.png" alt="image-20220321135828933"></p><p> <img src="/images/image-20220321140030238.png" alt="image-20220321140030238"></p><p><img src="/images/image-20220321140224765.png" alt="image-20220321140224765"></p><p><strong>当如上图情况发生的时候，开启一个新的数据页，元素50不会直接写到3#page上，找到1#page50%的位置，把23、47移动到新开启的数据页上，再将50插入到page3里，所以1号数据页指针下一个指向3了，需要对链表指针进行一个重新的设置。</strong></p><p><img src="/images/image-20220321140549668.png" alt="image-20220321140549668"></p><p>  <img src="/images/image-20220321140841426.png" alt="image-20220321140841426"></p><p><img src="/images/image-20220321140857458.png" alt="image-20220321140857458"></p><p><strong>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</strong></p><p><strong>为什么要降低主键的长度？</strong></p><p><strong>聚集索引只有一个，而二级索引有很多个，而在二级索引的叶子结点上，挂的就是主键。索引如果主键索引比较长，二级索引比较多，就会占用大量的磁盘空间。而且在搜索的时候会耗费大量的磁盘io。</strong></p><p><img src="/images/image-20220321202821939.png" alt="image-20220321202821939"></p><p><strong>uid、身份证之类的字段太长而且乱序。</strong></p><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p><img src="/images/image-20220321204028555.png" alt="image-20220321204028555"></p><p><strong>没有创建联合索引：using filesort</strong></p><p><strong>创建了联合索引：using index</strong></p><p><img src="/images/image-20220321204459840.png" alt="image-20220321204459840"></p><p><strong>反向扫描索引</strong></p><p><img src="/images/image-20220321204557080.png" alt="image-20220321204557080"></p><p><strong>因为创建索引的时候age是第一个字段，而在排序的时候phone是第一个字段，违背了最左前缀法则</strong></p><p><img src="/images/image-20220321204744263.png" alt="image-20220321204744263"></p><p><strong>出现这种情况的原因是：在创建索引的时候，如果没有指定顺序，默认是按照升序走的。</strong></p><p><strong>针对这个问题：</strong><img src="/images/image-20220321205108587.png" alt="image-20220321205108587"></p><p><img src="/images/image-20220321205143406.png" alt="image-20220321205143406"></p><p><strong>不会出现filesort了</strong></p><p><img src="/images/image-20220321205434838.png" alt="image-20220321205434838"></p><p><img src="/images/image-20220321205903064.png" alt="image-20220321205903064"> </p><p><img src="/images/image-20220321205808993.png" alt="image-20220321205808993"></p><h3 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h3><p><img src="/images/image-20220321211707870.png" alt="image-20220321211707870"></p><p>**用到了临时表，性能是比较低的 **   </p><p><img src="/images/image-20220321211915310.png" alt="image-20220321211915310"></p><p>**下面满足最左前缀法则，所以走索引  **</p><p><img src="/images/image-20220321212027369.png" alt="image-20220321212027369"></p><p><strong>满足最左前缀法则，where后面跟了prefession groupby后跟了age</strong></p><p><img src="/images/image-20220321212122375.png" alt="image-20220321212122375"></p><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p><img src="/images/image-20220321212627081.png" alt="image-20220321212627081"></p><p>**不支持子查询重的limit操作，采用多表联查  **</p><p><img src="/images/image-20220321212823263.png" alt="image-20220321212823263"></p><h3 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h3><p><img src="/images/image-20220321213920682.png" alt="image-20220321213920682"></p><p><img src="/images/image-20220321214208373.png" alt="image-20220321214208373"></p><p><strong>表中null值的情况，因为计数的每一行是不是null，所以为0</strong></p><p><img src="/images/image-20220321215349798.png" alt="image-20220321215349798"></p><p><strong>遇到计数不是null就加1</strong></p><p><img src="/images/image-20220321215652834.png" alt="image-20220321215652834"></p><p><img src="/images/image-20220321215708810.png" alt="image-20220321215708810"></p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p><img src="/images/image-20220322160227742.png" alt="image-20220322160227742"></p><p>**在执行更新的时候，更新的条件一定要有索引，如果没有索引，那么行锁会升级为表锁  **</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220322161154294.png" alt="image-20220322161154294"></p><h2 id="视图-存储过程-触发器"><a href="#视图-存储过程-触发器" class="headerlink" title="视图/存储过程/触发器"></a>视图/存储过程/触发器</h2><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><img src="/images/image-20220322161809406.png" alt="image-20220322161809406"></p><p><img src="/images/image-20220322162750139.png" alt="image-20220322162750139"></p><p><img src="/images/image-20220322163033901.png" alt="image-20220322163033901"></p><p><img src="/images/image-20220322165836343.png" alt="image-20220322165836343"></p><p><img src="/images/image-20220322170054942.png" alt="image-20220322170054942"></p><p><strong>v1插入id为6和30都能成功，因为没有加with check option</strong></p><p><img src="/images/image-20220322170458955.png" alt="image-20220322170458955"></p><p><strong>v2插入id为7和26的数据都无法成功，插入15能成功</strong></p><p><img src="/images/image-20220322170635683.png" alt="image-20220322170635683"></p><p><strong>11，17成功28失败，v3的插入条件继承与v2，17能成功也是因为没有加with check option</strong></p><p><img src="/images/image-20220322171557328.png" alt="image-20220322171557328"></p><p><strong>由于v4没有约束，于是插入id为5和16的数据都能成功</strong></p><p><strong>v5有约束，但是事local约束，id为13和17（与v4的≤15无关）都能插入成功</strong></p><p><strong>如果v4加入了local检查，那么v5插入id为18的数据将会失败</strong></p><p><strong>v6插入id为14的字段成功</strong></p><p><img src="/images/image-20220322172051395.png" alt="image-20220322172051395"></p><p><img src="/images/image-20220322172516771.png" alt="image-20220322172516771"></p><p><img src="/images/image-20220322173142745.png" alt="image-20220322173142745"></p><p><strong>数据独立：假如说主表的字段名发生变化，则可以通过视图的调整屏蔽影响，主表name-&gt;studentName,视图select studentName as name</strong></p><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p><img src="/images/image-20220323132744302.png" alt="image-20220323132744302"></p><p> <img src="/images/image-20220323132903277.png" alt="image-20220323132903277"></p><p> <img src="/images/image-20220323133210352.png" alt="image-20220323133210352"></p><p><img src="/images/image-20220323133830126.png" alt="image-20220323133830126"></p><p><img src="/images/image-20220323133903107.png" alt="image-20220323133903107"></p><p> <img src="/images/image-20220323134042860.png" alt="image-20220323134042860"></p><p> <img src="/images/image-20220323133710679.png" alt="image-20220323133710679"></p><p><strong>DEFINER字段不指定的话会默认加上</strong></p><p><strong>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符</strong>、</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br></pre></td></tr></table></figure><p><img src="/images/image-20220323135527638.png" alt="image-20220323135527638"></p><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a><strong>系统变量</strong></h4><p> <img src="/images/image-20220324125027263.png" alt="image-20220324125027263"></p><p><strong>session只代表的是当前会话，不会影响到其他会话</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#设置系统变量 </span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">0</span>; #不自动提交</span><br></pre></td></tr></table></figure><p><strong>设置了全局级别的参数所有的会话都会生效，但是当服务器重启之后</strong></p><p><img src="/images/image-20220324134333606.png" alt="image-20220324134333606"> </p><h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a><strong>用户变量</strong></h4><p><img src="/images/image-20220324134708642.png" alt="image-20220324134708642"></p><p><strong>推荐使用:= 因为在mysql中=既可以作为赋值运算符，又可以作为比较运算符</strong></p><p><img src="/images/image-20220324135123270.png" alt="image-20220324135123270"></p><p><strong>注意：用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</strong></p><p><strong>比如直接select @abc;结果为null（没有定义abc变量</strong></p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a><strong>局部变量</strong></h4><p> <img src="/images/image-20220324135730291.png" alt="image-20220324135730291"></p><p><img src="/images/image-20220324135956745.png" alt="image-20220324135956745"></p><p><strong>1.创建一个存储过程。2.声明局部变量。3.赋值。4.查询。5.调用存储过程。</strong></p><h4 id="if判断"><a href="#if判断" class="headerlink" title="if判断"></a>if判断</h4><p><img src="/images/image-20220324140508738.png" alt="image-20220324140508738"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">if score <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">elseif score <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">call</span> p3();</span><br><span class="line">#不及格</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><img src="/images/image-20220324141044272.png" alt="image-20220324141044272"></p><p><img src="/images/image-20220324145050721.png" alt="image-20220324145050721"></p><p>  <img src="/images/image-20220324145358704.png" alt="image-20220324145358704"></p><p><img src="/images/image-20220324145432246.png" alt="image-20220324145432246"></p><p><img src="/images/image-20220324145443285.png" alt="image-20220324145443285"></p><p> <img src="/images/image-20220324170316549.png" alt="image-20220324170316549"></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p><img src="/images/image-20220324170449743.png" alt="image-20220324170449743"></p><p><img src="/images/image-20220324170737857.png" alt="image-20220324170737857"></p><p><img src="/images/image-20220324170957272.png" alt="image-20220324170957272"></p><p>end;</p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p><img src="/images/image-20220324171213030.png" alt="image-20220324171213030"></p><p><img src="/images/image-20220324171314483.png" alt="image-20220324171314483"></p><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><p><img src="/images/image-20220324171750899.png" alt="image-20220324171750899"></p><p><img src="/images/image-20220324171950311.png" alt="image-20220324171950311"></p><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><p><img src="/images/image-20220324203642566.png" alt="image-20220324203642566"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#loop 计算从<span class="number">1</span>累加到n的值，n为传入的参数值</span><br><span class="line">#A 定义局部变量，记录累加之后的值</span><br><span class="line">#B 每循环一次，就会对n进行<span class="number">-1</span>，如果n减到<span class="number">0</span>，则退出循环<span class="comment">----&gt;leave xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum:loop</span><br><span class="line">if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">leave sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> loop sum;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">#loop 计算从<span class="number">1</span>到n之间的偶数累加的值，n为传入的参数值</span><br><span class="line">#A 定义局部变量，记录累加之后的值</span><br><span class="line">#B 每循环一次，就会对n进行<span class="number">-1</span>，如果n减到<span class="number">0</span>，则退出循环<span class="comment">----&gt;leave xx</span></span><br><span class="line">#C 如果当次累加的数据是奇数，则直接进入下一次循环<span class="comment">----&gt;iterate xx</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum:loop</span><br><span class="line">if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">leave sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line">if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">iterate sum;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> loop sum;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标-cursor"></a>游标-cursor</h4><p><img src="/images/image-20220324205333342.png" alt="image-20220324205333342"></p><p><img src="/images/image-20220324205444825.png" alt="image-20220324205444825"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#A 声明游标，存储查询结果集</span><br><span class="line">#B 准备：创建表结构</span><br><span class="line">#C 开启游标</span><br><span class="line">#D 获取游标中的记录</span><br><span class="line">#E 插入数据到新表中</span><br><span class="line">#F 关闭游标</span><br><span class="line">#要声明普通变量，再声明游标</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">      id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">      profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>,uname,upro); #id自增采用<span class="keyword">null</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    #循环体这么写会报错，[<span class="number">02000</span>][<span class="number">1329</span>]<span class="keyword">No</span> data <span class="operator">-</span> zero <span class="keyword">rows</span> fetched,selected,<span class="keyword">or</span> processed,因为while <span class="literal">true</span> 会一直执行下去</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="条件处理程序-handler"><a href="#条件处理程序-handler" class="headerlink" title="条件处理程序-handler"></a>条件处理程序-handler</h4><p><img src="/images/image-20220324211929100.png" alt="image-20220324211929100"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line">#<span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">close</span> u_cursor;</span><br><span class="line">#声明一个条件处理程序，当满足<span class="keyword">sql</span>状态码为<span class="number">02000</span>时触发，触发退出操作，将游标关闭掉 ，执行不会报错</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">      id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">      name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">      profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    ); </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> tb_user_pro <span class="keyword">values</span> (<span class="keyword">null</span>,uname,upro); #id自增采用<span class="keyword">null</span></span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p><img src="/images/image-20220325135333518.png" alt="image-20220325135333518"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> fun1(n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n :<span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">select</span> fun1(<span class="number">100</span>);#调用</span><br></pre></td></tr></table></figure><p><strong>存储函数用的比较少一点，因为存储函数能做的事情，存储过程也能做，存储函数必须要用返回值，存储过程可以设定参数的类型为out，就可以接收我存储过程执行的结果</strong></p><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p><img src="/images/image-20220325140232011.png" alt="image-20220325140232011"></p><p><strong>如果执行update型触发器影响了5行，触发器触发了5次，则称之为行级触发器，语句触发器指执行update，不管影响了多少行，只触发一次，那就是语句型触发器</strong></p><p><img src="/images/image-20220325140720034.png" alt="image-20220325140720034"></p><p><img src="/images/image-20220325141223803.png" alt="image-20220325141223803"></p><p>  <img src="/images/image-20220325141825320.png" alt="image-20220325141825320"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">VALUES</span></span><br><span class="line">#<span class="keyword">new</span>表示将要或者已经新增的数据</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.email,<span class="string">&#x27;,profession=&#x27;</span>,new.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"><span class="comment">-- 删除指定的触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br><span class="line"><span class="comment">-- 插入数据到tb_user</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看日志表 user_logs</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">VALUES</span></span><br><span class="line">#<span class="keyword">new</span>表示将要或者已经修改后的数据</span><br><span class="line">#<span class="keyword">old</span>表示修改之前的数据</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id,concat(<span class="string">&#x27;更新之前的数据为：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.email,<span class="string">&#x27;,profession=&#x27;</span>,old.profession,</span><br><span class="line">     <span class="string">&#x27;更新之后的数据为：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.email,<span class="string">&#x27;,profession=&#x27;</span>,new.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"># 行级触发器</span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> profession <span class="operator">=</span> <span class="string">&#x27;会计&#x27;</span> <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入数据触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id,operation,operate_time,operate_id,operate_params) <span class="keyword">VALUES</span></span><br><span class="line">#<span class="keyword">old</span>表示删除之前的数据</span><br><span class="line">(<span class="keyword">null</span>,<span class="string">&#x27;delete&#x27;</span>,now(),old.id,concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.email,<span class="string">&#x27;,profession=&#x27;</span>,old.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220325165240966.png" alt="image-20220325165240966"></p><h2 id="锁🔒"><a href="#锁🔒" class="headerlink" title="锁🔒"></a>锁🔒</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/image-20220325165648051.png" alt="image-20220325165648051"></p><p><img src="/images/image-20220325165753503.png" alt="image-20220325165753503"></p><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p><img src="/images/image-20220325171053195.png" alt="image-20220325171053195"></p><p><strong>加了全局锁之后：其他客户端不能执行数据操纵、数据删除，可以查询，整个过程中通过全局锁来解决全库的逻辑备份，从而保证逻辑备份的数据的一致性和完整性。</strong></p><p><img src="/images/image-20220325171236636.png" alt="image-20220325171236636"></p><p><strong>语法</strong></p><p><img src="/images/image-20220325171558878.png" alt="image-20220325171558878"></p><p><strong>逻辑备份之前加锁，逻辑备份之后去掉锁</strong></p><p><img src="/images/image-20220325172004445.png" alt="image-20220325172004445"></p><p> <img src="/images/image-20220325172309161.png" alt="image-20220325172309161"></p><p>**在mysql innoDB的底层实际上是通过快照读来实现的 **</p><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p> <img src="/images/image-20220325172731627.png" alt="image-20220325172731627"></p><p><img src="/images/image-20220325174320063.png" alt="image-20220325174320063"></p><p><strong>会阻塞直到另一个客户端的表锁的释放</strong></p><p><strong>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</strong></p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p><img src="/images/image-20220325175021695.png" alt="image-20220325175021695"></p><p><img src="/images/image-20220325175223961.png" alt="image-20220325175223961"></p><p><strong>此时右边阻塞，why？</strong></p><p><strong>因为当前有未提交的事务，在这个未提交的事务中，执行了select语句，自动加上了SHARED_READ锁，而右边使用了alter，就要对对应的表加上排他锁，排他锁与其他的锁互斥，阻塞到左侧事务提交</strong></p><p><img src="/images/image-20220325194656934.png" alt="image-20220325194656934"></p><p><img src="/images/image-20220325194933185.png" alt="image-20220325194933185"></p><p><strong>执行了select、update出现了两种锁</strong></p><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p><img src="/images/image-20220325195745751.png" alt="image-20220325195745751"></p><p><img src="/images/image-20220325195923752.png" alt="image-20220325195923752"></p><p><img src="/images/image-20220325200506826.png" alt="image-20220325200506826"></p><p><strong>当执行update语句的时候，会给相应的行加上行锁，也会自动给表加上意向锁</strong></p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p><img src="/images/image-20220325205228752.png" alt="image-20220325205228752"></p><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p><img src="/images/image-20220325205610571.png" alt="image-20220325205610571"></p><p><img src="/images/image-20220325205743794.png" alt="image-20220325205743794"></p><p><img src="/images/image-20220325205902299.png" alt="image-20220325205902299"></p><p><img src="/images/image-20220325210226248.png" alt="image-20220325210226248"></p><p><strong>共享锁与共享锁之间是兼容的</strong></p><p><img src="/images/image-20220325210530443.png" alt="image-20220325210530443"></p><p><strong>此时处于阻塞状态，是因为我们在更新的时候name是没有索引的，就会升级为表锁</strong></p><h4 id="间隙锁-临界锁"><a href="#间隙锁-临界锁" class="headerlink" title="间隙锁/临界锁"></a>间隙锁/临界锁</h4><p><img src="/images/image-20220325210727995.png" alt="image-20220325210727995"></p><p>  <img src="/images/image-20220325211407097.png" alt="image-20220325211407097"></p><p><strong>表示锁了3和8之间的间隙，插入id为7的数据会阻塞，防止幻读</strong></p><p> <img src="/images/image-20220325211610433.png" alt="image-20220325211610433"></p><p><strong>对于普通索引，18之前可能插入一个字段值为18的记录，18之后也有可能，对18-29之间的这段间隙，以及18之前的这段间隙加锁。</strong></p><p><img src="/images/image-20220325212116105.png" alt="image-20220325212116105"></p><p><strong>临界锁</strong></p><p><img src="/images/image-20220325212457395.png" alt="image-20220325212457395"></p><p><strong>当我们执行这条语句的时候，也就意味着会把19这行的行锁锁住，然后加了个临界锁锁的是25这行记录，与25之前的间隙，还有个临界锁锁的是正无穷大以及正无穷到25之间的间隙</strong></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/image-20220325212932671.png" alt="image-20220325212932671"></p><h3 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h3><h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h4><p><strong>表结构中所存储的记录以及索引都是在页这个逻辑结构中存储的</strong></p><p><img src="/images/image-20220325214819427.png" alt="image-20220325214819427"></p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="/images/image-20220325215009205.png" alt="image-20220325215009205"></p><p> <img src="/images/image-20220325220519853.png" alt="image-20220325220519853"></p><p>**当缓冲池里面的数据改了，但是磁盘中的数据还没有改，因为缓冲区的数据还没有刷新到磁盘上，所以这一类型的页称之为脏页  **</p><h4 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构 "></a>内存架构 <img src="/images/image-20220327104455840.png" alt="image-20220327104455840"></h4><p><strong>自适应哈希适用于等值匹配，不适用于范围查询</strong> </p><p><img src="/images/image-20220327105312507.png" alt="image-20220327105312507"></p><p><img src="/images/image-20220327105534332.png" alt="image-20220327105534332"></p><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><p><img src="/images/image-20220328172520740.png" alt="image-20220328172520740"></p><p>  <img src="/images/image-20220328175018469.png" alt="image-20220328175018469"></p><p> <img src="/images/image-20220328175227276.png" alt="image-20220328175227276"></p><p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0 ib_logfile1  </p><p><strong>后台线程</strong></p><p><img src="/images/image-20220328180324620.png" alt="image-20220328180324620"></p><p>**对于innodb的整个体系结构，当我们业务在操作的时候，那么会直接去操作缓冲区，如果缓冲区当中没有数据，会将磁盘当中的数据加载回来，然后再存储在缓冲区当中 。我们在增删改查的时候都会去操作缓冲区，缓冲区当中的数据会以一定的频率/时机要通过后台线程刷新到磁盘当中，然后在磁盘当中永久化的保存下来。 **</p><h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><p><img src="/images/image-20220328200653586.png" alt="image-20220328200653586"></p><p><strong>原子性、一致性、持久性是由redo log、undo log实现的</strong></p><p><strong>隔离性是由锁和MVCC实现的</strong></p><h5 id="持久性的保证"><a href="#持久性的保证" class="headerlink" title="持久性的保证"></a>持久性的保证</h5><p><strong>具体的操作流程</strong></p><p>首先，客户端在进行事务操作时会发起请求来操作我们的mysql服务器，在mysql服务器的innodb引擎中，分为内存结构和磁盘结构，磁盘结构里存放来很多的数据文件，内存结构中有很大的一块区域（buffer pool），在缓冲池中缓冲了我们一个个的数据页的信息。当我们进行update执行的时候，要去操作缓冲区，在缓冲区中要去查找，有没有我们所更新的这一块数据，如果没有，此时会通过后台线程把数据，从磁盘当中读取出来，然后缓存在缓冲区当中。那接下来就可以直接执行更新以及删除的操作，直接去操作缓冲区当中的数据 。 直接操作缓冲区的数据，磁盘中的数据没有更新，那这个时候就出现了脏页。脏页要在一定的时机通过后台线程刷新到磁盘当中。但脏页的数据并不是实时刷新的，而是一段时间之后，通过后台线程把脏页的数据刷新到磁盘当中。假如说脏页的数据在往磁盘结构中进行刷新的时候出错了，那么此时，我们内存中的数据没有刷新到磁盘当中，可是事务已经提交了，也告诉了用户事务提交成功了，但是最终在脏页刷新的时候失败了。<strong>那这时候持久性就没有得到保障</strong>。</p><p><strong>redolog重做日志出现之后的流程：</strong></p><p>当我们对缓冲区当中的数据进行了增删改之后，首先会把增删改的数据记录在redolog buffe中，在redolog buffer中又会去记录数据页的物理变化，当我们事务在提交的时候，会把redolog buffer中的数据页变化刷新到磁盘中 ，实体化得保存在磁盘文件上。再过一段时间后，在进行脏页刷新的时候，假如说出错了，可以通过redolog进行恢复。</p><p><strong>为什么在进行提交的时候要把redolog刷新到磁盘中？</strong></p><p>如果每一次提交的时候，不需要redolog，直接把bufferpool中的数据刷新到磁盘文件中，存在严重的性能问题。我们一般在事务中进行一组操作的时候，通常来说会操作很多条记录，而这些记录都是随机地去操作数据页，那么这个时候就会涉及到大量的随机磁盘io，性能比较低。如果用到了redolog，在事务提交时不会把脏页直接刷新，先把redolog文件刷新到磁盘中，由于是log日志文件，日志文件都是追加的，那么此时就是顺序磁盘io， 那么性能就是高于随机磁盘io的，这种机制叫做WAL。写入日志之后，再将脏页的数据刷新到磁盘中，如果说脏页的数据顺利的刷新到磁盘中了，那么此时redolog记录的数据变更也就不需要了，所以每隔一段时间就会去清理redolog，所以两份日志是循环使用的。</p><p><img src="/images/image-20220328210111465.png" alt="image-20220328210111465"></p><p><strong>redolog就是为了保证在进行脏页刷新发生错误时进行数据恢复，从而保证事务的持久性。</strong></p><h5 id="原子性的保证"><a href="#原子性的保证" class="headerlink" title="原子性的保证"></a>原子性的保证</h5><p><img src="/images/image-20220328212335339.png" alt="image-20220328212335339"></p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p><img src="/images/image-20220328213044947.png" alt="image-20220328213044947"></p><p><img src="/images/image-20220328213401564.png" alt="image-20220328213401564"></p><p><strong>查看ibd文件： ibd2sdi stu.ibd</strong></p><p><img src="/images/image-20220328214100687.png" alt="image-20220328214100687"></p><p><img src="/images/image-20220328215032714.png" alt="image-20220328215032714"></p><p> <img src="/images/image-20220328215625704.png" alt="image-20220328215625704"></p><p> <img src="/images/image-20220328220040423.png" alt="image-20220328220040423"></p><p><img src="/images/image-20220328220059165.png" alt="image-20220328220059165"></p><p>   <img src="/images/image-20220328220827833.png" alt="image-20220328220827833"></p><p><strong>事务5的第一次快照读结果为0x00002</strong></p><p><strong>第二次快照读的结果为0x00003</strong></p><p><img src="/images/image-20220328221225426.png" alt="image-20220328221225426"></p><p><img src="/images/image-20220328221328616.png" alt="image-20220328221328616"></p><p><strong>mvcc作用就是在进行快照读的时候要通过mvcc来查找对应的历史版本</strong></p><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p><img src="/images/image-20220329134640470.png" alt="image-20220329134640470"></p><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p><img src="/images/image-20220329135437788.png" alt="image-20220329135437788"></p><p><img src="/images/image-20220329135535284.png" alt="image-20220329135535284"></p><p><img src="/images/image-20220329145437109.png" alt="image-20220329145437109"></p><p><img src="/images/image-20220329145740151.png" alt="image-20220329145740151"></p><p><img src="/images/image-20220329150245518.png" alt="image-20220329150245518"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -p1234 db01 &gt; db01.sql </span><br></pre></td></tr></table></figure><p><img src="/images/image-20220329150801611.png" alt="image-20220329150801611"></p><p><strong>db02明显比db01小</strong></p><p><img src="/images/image-20220329151241341.png" alt="image-20220329151241341"></p><p><strong>去找mysql信任的目录</strong></p><p><img src="/images/image-20220329151345637.png" alt="image-20220329151345637"></p><p><img src="/images/image-20220329151456939.png" alt="image-20220329151456939"></p><p><img src="/images/image-20220329151615843.png" alt="image-20220329151615843"></p><p><img src="/images/image-20220329151759186.png" alt="image-20220329151759186"></p><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="/images/image-20220329152039341.png" alt="image-20220329152039341"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/image-20220305154604127.png&quot; alt=&quot;image-20220305</summary>
      
    
    
    
    
    <category term="数据库" scheme="https://lzjzzzzzzz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>About me</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/17/mee/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/17/mee/</id>
    <published>2022-04-17T12:41:02.000Z</published>
    <updated>2022-04-17T13:01:59.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找不到实习啊啊啊啊！！！"><a href="#找不到实习啊啊啊啊！！！" class="headerlink" title="找不到实习啊啊啊啊！！！"></a>找不到实习啊啊啊啊！！！</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;找不到实习啊啊啊啊！！！&quot;&gt;&lt;a href=&quot;#找不到实习啊啊啊啊！！！&quot; class=&quot;headerlink&quot; title=&quot;找不到实习啊啊啊啊！！！&quot;&gt;&lt;/a&gt;找不到实习啊啊啊啊！！！&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://lzjzzzzzzz.github.io/2022/04/17/hello-world/"/>
    <id>https://lzjzzzzzzz.github.io/2022/04/17/hello-world/</id>
    <published>2022-04-17T08:56:15.313Z</published>
    <updated>2022-04-18T04:05:20.079Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="1212" scheme="https://lzjzzzzzzz.github.io/tags/1212/"/>
    
  </entry>
  
</feed>
